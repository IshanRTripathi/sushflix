This file is a merged representation of a subset of the codebase

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
prisma/
  schema.prisma
scripts/
  analyze-bundle.js
src/
  components/
    auth/
      AuthContext.tsx
      AuthForm.tsx
      AuthModal.tsx
      LoginForm.tsx
      ProtectedRoute.tsx
      SignupForm.tsx
    common/
      FormField.tsx
      LoadingSpinner.tsx
      Modal.tsx
      SubmitButton.tsx
    content/
      components/
        ContentCard.tsx
        ContentCardActions.tsx
        ContentCardComments.tsx
        ContentCardHeader.tsx
        ContentCardMedia.tsx
        ContentCardSkeleton.tsx
        ContentDetail.tsx
        index.ts
        types.ts
      ContentCategories.tsx
      ContentUpload.tsx
      ExplorePage.tsx
      InteractionButtons.tsx
      PostCard.tsx
      ProfileSection.tsx
      types.ts
    creator/
      CreatorDashboard.tsx
      CreatorProfile.tsx
      CreatorSubscriptionCard.tsx
    layout/
      AppLayout.tsx
      Footer.tsx
      Header.tsx
      MoreMenu.tsx
      Navigation.tsx
      ProfileLayout.tsx
      Sidebar.tsx
    pages/
      FeaturedCard.tsx
      FeaturedProfilesSection.tsx
      HomePage.tsx
      HomePageModern.tsx
      HomePageNew.tsx
      ProfilePage.tsx
      SettingsPage.tsx
    profile/
      form/
        ProfileFormState.ts
        ProfileFormUI.tsx
        ProfileFormValidator.ts
      CoverPhotoUpload.tsx
      EditProfile.tsx
      EditProfileModal.tsx
      PostsGrid.tsx
      ProfileHeader.tsx
      ProfileLayout.tsx
      ProfilePictureUpload.tsx
      SocialLinks.tsx
      StatsSection.tsx
      types.ts
    settings/
      ThemeSettings.tsx
    subscription/
      SubscriptionPlans.tsx
    ui/
      Avatar.tsx
      Button.tsx
      Card.tsx
      CardContent.tsx
      CardDescription.tsx
      CardHeader.tsx
      CardTitle.tsx
      ErrorBoundary.tsx
      Icon.tsx
      IconButton.tsx
      Loading.tsx
      SkeletonLoader.tsx
      ThemeToggle.tsx
      UploadButton.tsx
    icons.tsx
    LoadingSpinner.tsx
    Toast.tsx
    UserProfilePage.tsx
  config/
    images.ts
    index.ts
  contexts/
    LoadingContext.tsx
    UIContext.tsx
  hooks/
    useApi.ts
    useAuth.ts
    useContentUploadForm.ts
    useForm.ts
    useLoading.ts
    useProfile.ts
    useProfileUpdate.ts
    useToast.ts
  server/
    config/
      db.js
      email.js
      logger.js
      socket.js
      stripe.js
    controllers/
      postController.js
      userController.js
    middlewares/
      auth.js
      authorization.js
      errorHandler.js
      requestLogger.js
      security.js
    models/
      Content.js
      FeaturedProfile.js
      Post.js
      Subscription.js
      User.js
      UserProfile.js
    requests/
      new_user_request.rest
    routes/
      auth.js
      content.js
      contentRoutes.js
      featuredProfiles.js
      post.js
      profiles.js
      subscriptions.js
      upload.js
      user.js
    services/
      analytics.js
      drm.js
      featuredProfileService.js
      search.js
      StorageService.js
    checkFeaturedProfiles.js
    devLogin.js
    Dockerfile
    package.json
    seedTestData.js
    server.js
  services/
    apiService.ts
    profileService.ts
    userProfileService.ts
  theme/
    components/
      ThemeProvider.tsx
    context/
      ThemeContext.ts
    hooks/
      useTheme.ts
    managers/
      ThemeManager.ts
    themes/
      base.ts
      dark.ts
      index.ts
      light.ts
    types/
      index.ts
    index.ts
    README.md
    types.ts
  types/
    auth.ts
    database.ts
    index.ts
    user.ts
  utils/
    browserEnv.ts
    constants.ts
    env.ts
    format.ts
    imageUtils.ts
    index.ts
    logger.ts
  App.tsx
  index.css
  main.tsx
  test-esm.js
  vite-env.d.ts
.babelrc
.browserslistrc
.editorconfig
.env.example
.eslintignore
.eslintrc.js
.gitattributes
.gitignore
.npmrc
.nvmrc
.prettierignore
.prettierrc
cloudbuild.yaml
cypress.config.ts
Dockerfile
Dockerfile.server
eslint.config.js
index.html
intro.txt
jest.config.js
nginx.conf
package.json
postcss.config.js
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.paths.json
tsconfig.server.json
vite.config.ts
webpack.config.js

================================================================
Files
================================================================

================
File: .idx/dev.nix
================
{pkgs}: {
  channel = "stable-24.05";
  packages = [
    pkgs.nodejs_20
  ];
  idx.extensions = [
    "svelte.svelte-vscode"
    "vue.volar"
  ];
  idx.previews = {
    previews = {
      web = {
        command = [
          "npm"
          "run"
          "dev"
          "--"
          "--port"
          "$PORT"
          "--host"
          "0.0.0.0"
        ];
        manager = "web";
      };
    };
  };
}

================
File: .theme-backup/context-ThemeContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}
⋮----
export function ThemeProvider(
⋮----
const toggleTheme = () =>
⋮----
export function useTheme()

================
File: .theme-backup/theme.css
================
:root {
[data-theme="dark"] {
body {
[data-theme="dark"] body {
.card {
[data-theme="dark"] .card {
.button {
[data-theme="dark"] .button {
.button:hover {
[data-theme="dark"] .button:hover {
.button:active {
[data-theme="dark"] .button:active {

================
File: .theme-backup/ThemeContext.tsx
================
import { createContext, useContext, useState, useEffect } from 'react';
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}
⋮----
export const ThemeProvider = (
⋮----
const toggleTheme = () =>
⋮----
export const useTheme = () =>

================
File: docs/architecture/UI_STATE_MANAGEMENT.md
================
# UI State Management

This document outlines the architecture and patterns used for managing UI state in the SushFlix application.

## Overview

The UI state management system is built using React Context and custom hooks to provide a centralized way to manage UI-related state across the application. This includes:

- Modal dialogs
- Sidebar state
- Navigation menus
- Toast notifications
- Loading states

## Architecture

### UIContext

The `UIContext` is the central hub for all UI-related state. It provides:

- Global state for UI components
- Methods to update the state
- Helper functions for common UI patterns

```typescript
interface UIContextType {
  // Navigation
  isSidebarOpen: boolean;
  isMoreMenuOpen: boolean;
  isMobileMenuOpen: boolean;
  
  // Actions
  toggleSidebar: () => void;
  toggleMoreMenu: () => void;
  toggleMobileMenu: () => void;
  closeAllMenus: () => void;
  openMoreMenu: () => void;
  closeMoreMenu: () => void;
}
```

## Usage

### Accessing UI State

```typescript
import { useUI } from '@/contexts/UIContext';

function MyComponent() {
  const { isSidebarOpen, toggleSidebar } = useUI();
  
  return (
    <div>
      <button onClick={toggleSidebar}>
        {isSidebarOpen ? 'Close' : 'Open'} Sidebar
      </button>
    </div>
  );
}
```

### Best Practices

1. **Use Custom Hooks**: Create custom hooks for complex UI logic
2. **Memoize Callbacks**: Use `useCallback` for functions passed as props
3. **Optimize Rerenders**: Use React.memo for pure components
4. **Clean Up**: Always clean up event listeners and subscriptions

## Components

### AppLayout

Main layout component that provides the overall structure and manages:
- Page layout
- Responsive behavior
- Modal overlays

### Navigation

Handles:
- Main navigation menu
- User menu
- Mobile responsiveness

### Sidebar

Manages:
- Sidebar visibility
- Navigation links
- Responsive behavior

## State Management Flow

1. **State Updates**: Components request state changes through context methods
2. **State Propagation**: Changes are propagated to all subscribed components
3. **Rerender**: Only affected components rerender

## Performance Considerations

- **Memoization**: Use `useMemo` for expensive calculations
- **Selective Rerenders**: Split context to prevent unnecessary rerenders
- **Lazy Loading**: Code split components where possible

## Testing

When testing components that use UI state:

1. Mock the `useUI` hook
2. Test different states independently
3. Verify proper cleanup

## Future Improvements

1. Add state persistence for user preferences
2. Implement more granular context providers
3. Add animations for state transitions
4. Improve error boundaries
5. Add more comprehensive TypeScript types

================
File: docs/cleanup/COMPONENTS.md
================
# Components Cleanup

## Overview
This document tracks the cleanup and optimization of components in the `/src/components` directory.

## Current Status
- **Status**: In Progress
- **Last Updated**: 2025-05-13
- **Target Directory**: `/src/components`

## Large Files (>300 lines)
| File Path | Size (lines) | Notes |
|-----------|-------------|-------|
| `UserProfilePage.tsx` | 366 | Needs refactoring |
| `ProfilePictureUpload.tsx` | 242 | Needs minor cleanup |

## Root Components Audit

### LoadingSpinner.tsx
- **Status**: ✅ Good
- **Size**: 10 lines
- **Issues**: None
- **Recommendations**: None

### Toast.tsx
- **Status**: ✅ Good
- **Size**: 20 lines
- **Issues**: None
- **Recommendations**: 
  - Consider adding prop types validation
  - Add JSDoc comments

### UserProfilePage.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 366 lines
- **Issues**:
  - Large component with multiple responsibilities
  - Inline styles mixed with Tailwind classes
  - Missing prop types validation
  - Complex form state management
- **Recommendations**:
  - Break down into smaller components
  - Move form logic to a custom hook
  - Add proper TypeScript interfaces
  - Improve error handling

### ContentUpload.tsx
- **Status**: ✅ Updated 2025-05-13
- **Size**: 356 lines
- **Recent Changes**:
  - Fixed TypeScript errors and improved type safety
  - Implemented proper drag-and-drop functionality
  - Added error handling for file uploads
  - Improved code organization and documentation
- **Recommendations**:
  - Consider adding more comprehensive form validation
  - Add unit tests for file upload functionality

### ProfilePictureUpload.tsx
- **Status**: ⚠️ Needs Minor Cleanup
- **Size**: 242 lines
- **Issues**:
  - Duplicate exports at the bottom
  - Some inline styles
  - Could benefit from more TypeScript types
- **Recommendations**:
  - Remove duplicate exports
  - Move styles to theme
  - Add more specific TypeScript types
  - Consider adding loading states

## Authentication Components Audit

### AuthContext.tsx
- **Status**: ✅ Good
- **Size**: 180 lines
- **Features**:
  - User authentication state management
  - Login/logout functionality
  - Session persistence
- **Recommendations**:
  - Add token refresh logic
  - Add more detailed error handling
  - Add JWT expiration handling

### AuthForm.tsx
- **Status**: ✅ Good
- **Size**: 181 lines
- **Features**:
  - Reusable form component for authentication
  - Form validation
  - Error handling and display
  - Accessible form controls
- **Recommendations**:
  - Add password strength meter
  - Add show/hide password toggle
  - Add support for password managers
  - Add loading states for form submission

### LoginForm.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 267 lines
- **Issues**:
  - Large component with multiple responsibilities
  - Complex state management
  - Mixed concerns between UI and business logic
- **Features**:
  - Phone and email login options
  - Form validation
  - Error handling
  - Loading states
- **Recommendations**:
  - Split into smaller components
  - Move business logic to custom hooks
  - Extract form validation to separate utility
  - Add rate limiting for failed attempts
  - Add "Remember me" functionality
  - Add "Forgot password" link

### SignupForm.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 293 lines
- **Issues**:
  - Large component with multiple responsibilities
  - Complex state management
  - Mixed concerns between UI and business logic
- **Features**:
  - Form validation with retry logic
  - Error handling and display
  - Loading states
  - Integration with auth context
- **Recommendations**:
  - Split into smaller components
  - Move business logic to custom hooks
  - Add password confirmation field
  - Add terms and conditions acceptance
  - Add email verification flow
  - Add social signup options

### ProtectedRoute.tsx
- **Status**: ✅ Good
- **Size**: 59 lines
- **Features**:
  - Role-based access control
  - Authentication protection
  - Route redirection
  - Logging for unauthorized access attempts
- **Recommendations**:
  - Add support for multiple required roles
  - Add custom permission checks
  - Add loading state while checking auth status
  - Add support for route-specific permissions

### AuthModal.tsx
- **Status**: ✅ Good
- **Size**: 50 lines
- **Features**:
  - Modal dialog for authentication
  - Toggle between login and signup forms
  - Clean, accessible UI
- **Recommendations**:
  - Add ARIA attributes
  - Improve keyboard navigation
  - Add focus management
  - Add animation for better UX

## Common Components Audit

### Modal.tsx
- **Status**: ✅ Excellent
- **Size**: 140 lines
- **Features**:
  - Accessible modal implementation
  - Size and variant support
  - Keyboard navigation
  - Click outside to close
  - Escape key to close
  - Custom styling support
- **Recommendations**:
  - Add animation support
  - Add focus trap
  - Add scroll lock
  - Consider using a portal

### LoadingSpinner.tsx
- **Status**: ✅ Good
- **Size**: 30 lines
- **Features**:
  - Simple loading indicator
  - Customizable size and color
- **Recommendations**:
  - Add more variants
  - Consider using a more engaging animation

### FormField.tsx
- **Status**: ✅ Good
- **Size**: 90 lines
- **Features**:
  - Form field with label and error handling
  - Support for different input types
  - Validation support
- **Recommendations**:
  - Add more input types
  - Improve accessibility
  - Add support for icons

### SubmitButton.tsx
- **Status**: ✅ Good
- **Size**: 45 lines
- **Features**:
  - Loading state support
  - Disabled state
  - Customizable text and styles
- **Recommendations**:
  - Add more variants
  - Improve accessibility
  - Add success/error states

## Content Components Audit

### ContentCard.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 279 lines
- **Issues**:
  - Large component with multiple responsibilities
  - Inline styles mixed with styled-components
  - Complex state management
  - Direct API calls in component
- **Features**:
  - Like/unlike functionality
  - Comments section toggle
  - User interactions (share, bookmark)
  - Loading states with skeleton UI
  - Error handling
- **Recommendations**:
  - Break down into smaller components (Header, Media, Actions, Comments)
  - Move API calls to a service layer
  - Add prop types validation
  - Implement proper error boundaries
  - Add tests for user interactions
  - Improve accessibility

### ContentCardActions.tsx
- **Status**: ✅ Good
- **Size**: 70 lines
- **Features**:
  - Like, comment, share, and bookmark actions
  - Loading states
  - Interactive elements with hover states
- **Recommendations**:
  - Add tooltips for better UX
  - Implement proper error handling for actions
  - Add keyboard navigation support
  - Add ARIA labels for accessibility

### ContentCardComments.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 36 lines
- **Issues**:
  - Basic implementation
  - Missing loading states
  - Limited functionality
- **Features**:
  - Comments list display
  - Basic styling
- **Recommendations**:
  - Add comment editing and deletion
  - Implement proper loading states
  - Add pagination for long comment lists
  - Improve error handling
  - Add user avatars and timestamps

### ContentCardHeader.tsx
- **Status**: ⚠️ Incomplete
- **Size**: 27 lines
- **Issues**:
  - Only shows skeleton loader
  - Missing actual implementation
- **Recommendations**:
  - Implement the actual header component
  - Add user avatar and name
  - Include timestamp and follow button
  - Add loading states

### ContentCardMedia.tsx
- **Status**: ✅ Good
- **Size**: 36 lines
- **Features**:
  - Responsive media display
  - Loading states with skeleton
  - Error handling for images
- **Recommendations**:
  - Add support for different media types
  - Implement lazy loading
  - Add zoom/expand functionality
  - Add alt text for accessibility

### ContentCardSkeleton.tsx
- **Status**: ✅ Good
- **Size**: 15 lines
- **Features**:
  - Simple skeleton loader
  - Matches card layout
- **Recommendations**:
  - Add more skeleton variations
  - Match the actual content structure better
  - Add animation for better UX

### ContentDetail.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 343 lines
- **Issues**:
  - Very large component
  - Mixes presentation and data fetching
  - Complex state management
- **Features**:
  - Detailed content view
  - Media player with error handling
  - Like and bookmark functionality
  - Creator information
  - Related content section
- **Recommendations**:
  - Split into smaller components
  - Move data fetching to custom hooks
  - Add proper error boundaries
  - Implement proper loading states
  - Add tests
  - Improve accessibility

### types.ts
- **Status**: ⚠️ Needs Work
- **Size**: 24 lines
- **Issues**:
  - Limited type definitions
  - Missing some component props
- **Recommendations**:
  - Add comprehensive type definitions
  - Document all types with JSDoc
  - Create separate interfaces for props
  - Add type guards for runtime validation

### ContentUpload.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 267 lines
- **Issues**:
  - Very large component
  - Complex form state management
  - No proper validation
  - No error boundaries
- **Recommendations**:
  - Split into smaller components
  - Use Formik or React Hook Form
  - Add proper validation schema
  - Implement proper error handling
  - Add loading states
  - Add success/error toasts

### ContentCategories.tsx
- **Status**: ✅ Good
- **Size**: 150 lines (estimated)
- **Features**:
  - Category selection
  - Filtering
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add error handling

### ExplorePage.tsx
- **Status**: ✅ Good
- **Size**: 120 lines (estimated)
- **Features**:
  - Content discovery
  - Search functionality
- **Recommendations**:
  - Add infinite scroll
  - Improve performance
  - Add filters

### InteractionButtons.tsx
- **Status**: ✅ Good
- **Size**: 50 lines (estimated)
- **Features**:
  - Like, comment, share actions
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add tooltips

### ProfileSection.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 230 lines (estimated)
- **Issues**:
  - Large component
  - Mixing concerns
- **Recommendations**:
  - Split into smaller components
  - Move logic to custom hooks
  - Add loading states
  - Improve error handling

## Layout Components Audit

### Header.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 150 lines
- **Issues**:
  - Duplicate menu items
  - Inline styles
  - No loading states
  - Complex conditional rendering
- **Recommendations**:
  - Extract menu items to config
  - Move styles to CSS modules
  - Add loading states
  - Use compound components
  - Add error boundaries

### Navigation.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 210 lines
- **Issues**:
  - Very large component
  - Duplicate markup for mobile/desktop
  - Complex conditional logic
  - Inline styles
- **Recommendations**:
  - Split into smaller components
  - Use composition
  - Move styles to theme
  - Add loading states
  - Improve accessibility

### ProfileLayout.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 60 lines
- **Issues**:
  - Mock data in component
  - No error handling
  - No loading states
  - Hardcoded values
- **Recommendations**:
  - Move data fetching to hooks
  - Add proper error boundaries
  - Implement loading states
  - Use environment variables
  - Add prop types

### AppLayout.tsx
- **Status**: ✅ Good
- **Size**: 30 lines (estimated)
- **Features**:
  - Basic layout structure
  - Theme provider
- **Recommendations**:
  - Add error boundaries
  - Add loading states
  - Improve accessibility

### Footer.tsx
- **Status**: ✅ Good
- **Size**: 90 lines (estimated)
- **Features**:
  - Copyright info
  - Navigation links
- **Recommendations**:
  - Add social links
  - Improve responsive design
  - Add sitemap

### MoreMenu.tsx
- **Status**: ✅ Good
- **Size**: 80 lines (estimated)
- **Features**:
  - Dropdown menu
  - Theme support
- **Recommendations**:
  - Add keyboard navigation
  - Improve accessibility
  - Add animations

### Sidebar.tsx
- **Status**: ✅ Good
- **Size**: 40 lines (estimated)
- **Features**:
  - Basic sidebar
  - Navigation links
- **Recommendations**:
  - Add collapsible sections
  - Improve responsive design
  - Add active states

## Profile Components Audit

### ProfileHeader.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 440 lines
- **Issues**:
  - Very large component
  - Complex state management
  - Inline styles
  - No prop types validation
  - No loading states for async operations
- **Recommendations**:
  - Split into smaller components
  - Move styles to theme
  - Add prop types validation
  - Implement proper loading states
  - Add error boundaries
  - Extract social links to a separate component

### ProfileLayout.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 180 lines
- **Issues**:
  - Complex state management
  - No proper error boundaries
  - Inline styles
  - No loading states for async operations
- **Recommendations**:
  - Move state management to context/reducer
  - Add error boundaries
  - Extract styles to theme
  - Implement proper loading states
  - Add prop types validation

### ProfilePictureUpload.tsx
- **Status**: ✅ Good
- **Size**: 80 lines (estimated)
- **Features**:
  - Image upload
  - Preview
  - Error handling
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add prop types

### EditProfileModal.tsx
- **Status**: ✅ Good
- **Size**: 70 lines (estimated)
- **Features**:
  - Form validation
  - Error handling
  - Success messages
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add prop types

### StatsSection.tsx
- **Status**: ✅ Good
- **Size**: 50 lines (estimated)
- **Features**:
  - Displays user stats
  - Responsive design
- **Recommendations**:
  - Add loading states
  - Add animations
  - Improve accessibility

### SocialLinks.tsx
- **Status**: ✅ Good
- **Size**: 40 lines (estimated)
- **Features**:
  - Displays social links
  - Icons for each platform
- **Recommendations**:
  - Add tooltips
  - Improve accessibility
  - Add loading states

### PostsGrid.tsx
- **Status**: ✅ Good
- **Size**: 60 lines (estimated)
- **Features**:
  - Displays posts in a grid
  - Responsive design
- **Recommendations**:
  - Add loading states
  - Add error handling
  - Add empty state

## Content Components Audit

### PostCard.tsx
- **Status**: ✅ Good
- **Size**: 210 lines
- **Features**:
  - Displays post content
  - Handles likes, comments, shares
  - Responsive design
  - Loading states
  - Error handling
- **Recommendations**:
  - Add prop types validation
  - Improve accessibility
  - Add tests
  - Add animations

### ContentUpload.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 270 lines
- **Issues**:
  - Very large component
  - Complex form handling
  - No proper error boundaries
  - Inline styles
- **Recommendations**:
  - Split into smaller components
  - Move form logic to a custom hook
  - Add proper error boundaries
  - Extract styles to theme
  - Add loading states
  - Improve accessibility

### ExplorePage.tsx
- **Status**: ⚠️ Needs Refactoring
- **Size**: 160 lines
- **Issues**:
  - Mock data in component
  - No loading states
  - No error boundaries
  - Hardcoded values
- **Recommendations**:
  - Move data fetching to a custom hook
  - Add loading states
  - Add error boundaries
  - Use environment variables
  - Add prop types validation

### ContentCategories.tsx
- **Status**: ✅ Good
- **Size**: 50 lines (estimated)
- **Features**:
  - Displays content categories
  - Responsive design
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add animations

### InteractionButtons.tsx
- **Status**: ✅ Good
- **Size**: 40 lines (estimated)
- **Features**:
  - Handles likes, comments, shares
  - Responsive design
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add tooltips

### ProfileSection.tsx
- **Status**: ✅ Good
- **Size**: 90 lines (estimated)
- **Features**:
  - Displays user profile
  - Responsive design
- **Recommendations**:
  - Add loading states
  - Improve accessibility
  - Add animations

## Authentication Components Audit

### AuthContext.tsx
- **Status**: ✅ Good
- **Size**: 180 lines
- **Features**:
  - User authentication state management
  - Login/logout functionality
  - Session persistence
- **Recommendations**:
  - Add token refresh logic
  - Add more detailed error handling
  - Add JWT expiration handling

### AuthForm.tsx
### AuthModal.tsx
- **Status**: ✅ Good
- **Size**: 50 lines (estimated)
- **Features**:
  - Modal for authentication
  - Toggle between login and signup forms
  - Accessible
- **Recommendations**:
  - Add animations
  - Improve error handling
  - Add tests

### LoginForm.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 270 lines
- **Issues**:
  - Large component
  - Complex state management
  - No form validation library
  - No proper error boundaries
- **Recommendations**:
  - Split into smaller components
  - Use Formik or React Hook Form
  - Add proper error boundaries
  - Add loading states
  - Improve accessibility

### SignupForm.tsx
- **Status**: ⚠️ Needs Work
- **Size**: 250 lines (estimated)
- **Issues**:
  - Large component
  - Complex state management
  - No form validation library
  - No proper error boundaries
- **Recommendations**:
  - Split into smaller components
  - Use Formik or React Hook Form
  - Add proper error boundaries
  - Add loading states
  - Improve accessibility

### ProtectedRoute.tsx
- **Status**: ✅ Good
- **Size**: 40 lines (estimated)
- **Features**:
  - Protects routes from unauthorized access
  - Redirects to login if not authenticated
  - Handles loading states
- **Recommendations**:
  - Add role-based access control
  - Add tests
  - Improve error handling

## Common Components Audit

### LoadingSpinner.tsx
- **Status**: ✅ Good
- **Size**: 75 lines
- **Features**:
  - Reusable loading spinner
  - Multiple size variants
  - Color variants
  - Accessible
  - Dark mode support
- **Recommendations**:
  - Add animation customization
  - Add tests
  - Add more color variants

### Modal.tsx
- **Status**: ✅ Good
- **Size**: 140 lines
- **Features**:
  - Reusable modal component
  - Multiple size variants
  - Visual variants
  - Keyboard navigation
  - Accessible
  - Dark mode support
- **Recommendations**:
  - Add animations
  - Add tests
  - Add more customization options

### FormField.tsx
- **Status**: ✅ Good
- **Size**: 80 lines (estimated)
- **Features**:
  - Reusable form field
  - Error handling
  - Label and helper text
  - Accessible
- **Recommendations**:
  - Add more input types
  - Add tests
  - Add more customization options

### SubmitButton.tsx
- **Status**: ✅ Good
- **Size**: 50 lines (estimated)
- **Features**:
  - Reusable submit button
  - Loading state
  - Accessible
- **Recommendations**:
  - Add more variants
  - Add tests
  - Add more customization options

## Audit Checklist

### 1. Component Structure
- [ ] Check for duplicate components
- [ ] Identify similar components that could be consolidated
- [ ] Verify component naming consistency (PascalCase)
- [ ] Ensure proper file structure

### 2. Imports & Exports
- [ ] Check for unused imports
- [ ] Verify consistent import order
- [ ] Ensure proper named/default exports
- [ ] Check for circular dependencies

### 3. Props & Types
- [ ] Add missing prop types
- [ ] Document all props with JSDoc
- [ ] Remove any `any` types
- [ ] Ensure consistent prop naming

### 4. Styling
- [ ] Check for inline styles that should be in theme
- [ ] Verify consistent spacing units
- [ ] Ensure responsive design patterns
- [ ] Check for unused styles

## Findings

### Components Directory Structure
```
components/
├── auth/          # Authentication related components
├── common/        # Shared components
├── content/       # Content display components
├── creator/       # Creator-specific components
├── layout/        # Layout components
├── pages/         # Page components
├── profile/       # Profile related components
├── settings/      # Settings components
├── subscription/  # Subscription components
└── ui/            # Base UI components
```

## Action Items

### High Priority
1. Audit `profile/` components for duplicates
2. Standardize component interfaces
3. Document prop types

### Medium Priority
1. Review component composition
2. Optimize re-renders
3. Add loading states

### Low Priority
1. Add storybook stories
2. Add component tests
3. Document usage examples

## Progress Log

### 2025-05-12
- Initial documentation created
- Directory structure analyzed
- Next: Start audit of profile components

## Notes
- Pay special attention to shared state between components
- Document any patterns or conventions found
- Keep an eye on component dependencies
- Note any performance bottlenecks

================
File: docs/cleanup/CONFIG.md
================
# Configuration Cleanup

## Overview
This document tracks the cleanup and optimization of configuration files across the project.

## Current Status
- **Status**: In Progress (Phase 1)
- **Last Updated**: 2025-05-13
- **Recent Changes**:
  - Migrated all configurations to ES modules
  - Updated Vite to v5.1.4
  - Fixed TypeScript configurations for ESM
  - Updated PostCSS and Tailwind configurations
  - Improved module resolution
- **Target Directories**: 
  - `/config`
  - `/public`
  - Root config files
- **Dependencies**:
  - Types Cleanup (Phase 1)
  - Utils Cleanup (Phase 1)
  - Environment files

## Configuration Inventory

### Build & Tooling
| File | Purpose | Status | Notes |
|------|---------|--------|-------|
| `vite.config.ts` | Vite configuration | ✅ Updated | Migrated to ESM, added type safety |
| `tsconfig.json` | TypeScript config | ✅ Updated | Configured for ESM, strict type checking |
| `tailwind.config.js` | Tailwind CSS config | ✅ Updated | ESM support, optimized purge settings |
| `postcss.config.js` | PostCSS config | ✅ Updated | ESM support, optimized plugins |
| `.eslintrc.js` | ESLint config | Will audit | Update rules |
| `.prettierrc` | Prettier config | Will audit | Ensure consistency |

### Environment
| File | Purpose | Status | Notes |
|------|---------|--------|-------|
| `.env` | Environment variables | Will audit | Check for sensitive data |
| `.env.development` | Dev env variables | Will audit | Review defaults |
| `.env.production` | Production env vars | Will audit | Check security |
| `.env.example` | Example env file | Will audit | Keep in sync |

## Audit Checklist

### 1. Configuration Files Review
- [x] **Build Tools**
  - [x] Optimize Vite configuration
  - [x] Update TypeScript compiler options
  - [x] Review Tailwind configuration
  - [x] Check PostCSS plugins
  - [x] Update ESLint/Prettier rules

- [ ] **Environment Management**
  ```env
  # Example .env structure
  VITE_API_URL=https://api.example.com
  VITE_ENV=development
  VITE_SENTRY_DSN=your-sentry-dsn
  ```
  - [x] Document all environment variables
  - [x] Add validation for required variables
  - [x] Secure sensitive data
  - [x] Create .env.example template

### 2. Build & Optimization
- [x] **Build Configuration**
  - [x] Optimize production build
  - [x] Configure proper source maps
  - [x] Set up environment-specific builds
  - [x] Implement proper caching strategy

- [ ] **Performance**
  - [ ] Configure code splitting
  - [ ] Optimize asset loading
  - [ ] Set up bundle analysis
  - [ ] Configure compression

### 3. Security & Best Practices
- [x] **Security**
  - [x] Review CSP headers
  - [x] Check for exposed API keys
  - [x] Validate environment variables
  - [x] Set up proper CORS configuration
  - [x] Add environment variable validation
  - [x] Secure sensitive configuration

- [ ] **Documentation**
  - [ ] Document configuration options
  - [ ] Add setup instructions
  - [ ] Document environment setup
  - [ ] Add troubleshooting guide

### 4. Documentation
- [x] Document all configuration options
- [ ] Add examples for different environments
- [ ] Document required vs optional settings
- [ ] Add troubleshooting section

## Implementation Details

### Environment Validation
- Added runtime validation for environment variables using Zod
- Created separate validation for client and server environments
- Added type safety for environment variables
- Implemented proper error handling for missing/invalid configuration

### Security Improvements
- Secured sensitive environment variables
- Added proper CORS configuration
- Implemented rate limiting
- Added Content Security Policy (CSP) headers

### ES Modules Migration
- Converted all configuration files to use ES modules syntax
- Updated import/export statements
- Fixed module resolution paths
- Ensured compatibility with Vite 5.1.4

### TypeScript Configuration
- Updated `tsconfig.app.json` and `tsconfig.node.json`
- Enabled strict type checking
- Improved module resolution
- Added proper type definitions

### Build Optimization
- Configured Vite for optimal development and production builds
- Set up proper source maps
- Implemented environment-specific configurations
- Added proper caching headers

## Common Issues to Address

### Configuration
- ~~Hardcoded configuration values~~ (Resolved)
- ~~Missing or outdated documentation~~ (In Progress)
- ~~Inconsistent environment setup~~ (Resolved)
- Security vulnerabilities (Review Needed)
- Performance bottlenecks (Review Needed)

### Security
- Exposed API keys
- Missing CORS configuration
- Insecure environment variables
- Missing rate limiting
- Outdated dependencies

## Best Practices

### Environment Management
```javascript
// config/env.js
export const env = {
  apiUrl: import.meta.env.VITE_API_URL,
  env: import.meta.env.VITE_ENV,
  sentryDsn: import.meta.env.VITE_SENTRY_DSN,
  // Add validation
  isProduction: import.meta.env.VITE_ENV === 'production',
  isDevelopment: import.meta.env.VITE_ENV === 'development',
};

// Validate required variables
const requiredVars = ['VITE_API_URL'];
requiredVars.forEach(varName => {
  if (!import.meta.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
});

export default env;
```

### Vite Configuration
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { visualizer } from 'rollup-plugin-visualizer';

export default defineConfig(({ mode }) => ({
  plugins: [
    react(),
    mode === 'analyze' && visualizer({
      open: true,
      filename: 'dist/stats.html',
    }),
  ].filter(Boolean),
  build: {
    sourcemap: mode === 'development',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
        },
      },
    },
  },
  server: {
    port: 5173,
    open: true,
  },
}));
```

### TypeScript Configuration
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}

## Next Steps
1. Audit build configuration
2. Review environment variables
3. Optimize build process
4. Document configuration options

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Documented configuration files
- Added audit checklist
- Identified optimization targets

## Action Items

### High Priority
1. Audit environment variables
2. Secure sensitive configuration
3. Document all configuration options
4. Set up proper build optimization
2. Review build configuration
3. Set up proper TypeScript configuration

### Medium Priority
1. Add validation for configuration
2. Document configuration options
3. Set up environment-specific configs

### Low Priority
1. Add configuration tests
2. Create configuration templates
3. Document deployment requirements

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Document environment variables

## Notes
- Keep sensitive values out of version control
- Document all configuration options
- Validate configuration at startup
- Consider using a configuration management library if needed

================
File: docs/cleanup/ERRORS.md
================
# Error Handling Cleanup

## Overview
This document tracks the cleanup and standardization of error handling across the application.

## Current Status
- **Status**: Not Started
- **Last Updated**: 2025-05-12
- **Target Areas**: 
  - API error handling
  - User-facing errors
  - Error boundaries
  - Error logging

## Error Handling Inventory

### Error Boundaries
| Component | File | Status | Notes |
|-----------|------|--------|-------|
| TBD | - | - | - |

### Error Types
| Type | Description | Status |
|------|-------------|--------|
| API Errors | Server/network errors | - |
| Validation Errors | Form/input validation | - |
| Runtime Errors | Application crashes | - |
| Permission Errors | Access control | - |

## Audit Checklist

### 1. Error Boundaries
- [ ] Add error boundaries to all routes
- [ ] Create reusable error boundary component
- [ ] Add error recovery options
- [ ] Log boundary errors

### 2. API Error Handling
- [ ] Standardize error responses
- [ ] Add proper error types
- [ ] Implement retry logic
- [ ] Add error logging

### 3. User Feedback
- [ ] Create error message components
- [ ] Add loading states
- [ ] Implement empty states
- [ ] Add error recovery options

### 4. Error Logging
- [ ] Implement error tracking
- [ ] Log to appropriate service
- [ ] Add user context to logs
- [ ] Set up error alerts

## Common Issues to Address
- Unhandled promise rejections
- Missing error boundaries
- Uninformative error messages
- Lack of error recovery

## Action Items

### High Priority
1. Add error boundaries
2. Standardize API error handling
3. Implement error logging

### Next Steps
1. Implement error boundaries
2. Create error components
3. Set up error tracking
4. Document error handling patterns

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Documented error handling standards
- Added error inventory
- Created audit checklist

### Medium Priority
1. Create error components
2. Add loading states
3. Document error handling patterns

### Low Priority
1. Add error analytics
2. Create error monitoring
3. Document common errors

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Add error boundaries

## Notes
- Keep error messages user-friendly
- Log detailed error information
- Consider error tracking services
- Document error handling patterns

================
File: docs/cleanup/HOOKS.md
================
# Hooks Cleanup

## Overview
This document tracks the cleanup and optimization of custom hooks in the `/src/hooks` directory.

## Current Status
- **Status**: In Progress (Phase 1)
- **Last Updated**: 2025-05-13
- **Target Directory**: `/src/hooks`
- **Dependencies**: 
  - ✅ Components Audit (Phase 1)
  - ✅ Types Cleanup (Phase 1)

## Hooks Inventory

### Custom Hooks
| Hook Name | File | Dependencies | Status | Notes |
|-----------|------|--------------|--------|-------|
| useApi | `useApi.ts` | - | Needs audit | API request handling |
| useAuth | `useAuth.ts` | AuthContext | Needs audit | Authentication state |
| useContentUploadForm | `useContentUploadForm.ts` | useAuth | Needs audit | Content upload form handling |
| useForm | `useForm.ts` | - | ✅ Enhanced | Form state management with validation |
| useLoading | `useLoading.ts` | - | ✅ Enhanced | Advanced loading state management with error handling and time tracking |
| useProfile | `useProfile.ts` | useAuth, useLoading | ✅ Enhanced | User profile management with type safety and error handling |
| useProfileUpdate | `useProfileUpdate.ts` | useToast | Needs audit | Profile update handling |
| useToast | `useToast.ts` | - | Needs audit | Toast notifications |

### Third-party Hooks
| Hook | Source | Usage Count | Notes |
|------|--------|-------------|-------|
| useState | React | Multiple | Core hook |
| useEffect | React | Multiple | Core hook |
| useCallback | React | Multiple | Performance |
| useMemo | React | Multiple | Performance |
| useReducer | React | Few | Complex state |
| useRef | React | Multiple | Refs |
| useParams | React Router | Multiple | URL parameters |
| useNavigate | React Router | Multiple | Navigation |
| useLocation | React Router | Few | Current route info |

## Audit Checklist

### 1. Hook Implementation Review
- [ ] **Code Quality**
  - [x] Verify hook naming follows `useSomething` convention
  - [ ] Ensure proper dependency arrays in useEffect/useCallback
  - [ ] Check for potential memory leaks
  - [ ] Verify cleanup in useEffect
  - [ ] Check for duplicate hook logic

- [ ] **Type Safety**
  - [ ] Add proper TypeScript types
  - [ ] Remove `any` types (especially in useAuth.ts)
  - [ ] Add input validation
  - [ ] Document expected types with JSDoc

### 2. Performance Optimization
- [ ] **Rendering**
  - [ ] Identify unnecessary re-renders
  - [ ] Implement useCallback for event handlers
  - [ ] Use useMemo for expensive calculations
  - [ ] Optimize context usage to prevent unnecessary updates

- [ ] **Memory**
  - [ ] Check for memory leaks
  - [ ] Clean up subscriptions and event listeners
  - [ ] Use refs for mutable values that shouldn't trigger re-renders

### 3. Error Handling & Debugging
- [ ] **Error Boundaries**
  - [ ] Add error boundaries around hook usage
  - [ ] Implement proper error states
  - [ ] Add error recovery mechanisms

- [ ] **Logging**
  - [ ] Add debug logging for development
  - [ ] Log errors appropriately
  - [ ] Add performance metrics

### 4. Documentation & Testing
- [ ] **JSDoc Comments**
  ```typescript
  /**
   * Custom hook for handling authentication state
   * @param {AuthConfig} config - Configuration options
   * @returns {AuthState} Current authentication state and methods
   * @example
   * const { user, login, logout } = useAuth();
   */
  function useAuth(config: AuthConfig): AuthState;
  ```

- [ ] **Testing**
  - [ ] Add unit tests for each hook
  - [ ] Test error cases
  - [ ] Test cleanup behavior
  - [ ] Add integration tests for hook composition

## useAuth Hook Documentation

### Overview
The `useAuth` hook provides authentication state management and authentication-related operations like login, signup, and logout.

### Features
- Authentication state management
- Login with email/password or OTP
- User registration
- Token-based authentication
- Automatic token refresh
- Protected route integration

### API

```typescript
interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  loading: boolean;
}

interface LoginCredentials {
  identifier: string;
  password: string;
  authMethod: 'password' | 'otp';
}

interface SignupData {
  username: string;
  email: string;
  password: string;
  isCreator: boolean;
  displayName: string;
  profilePic: string;
}

const {
  isAuthenticated,  // Whether user is authenticated
  user,             // Current user profile
  loading,          // Initial loading state
  login,            // Login function
  signup,           // Signup function
  logout,           // Logout function
  refreshToken,     // Refresh access token
  error             // Current error, if any
} = useAuth();
```

### Usage Example

```typescript
function LoginForm() {
  const { login, loading, error } = useAuth();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await login({
        identifier: 'user@example.com',
        password: 'password',
        authMethod: 'password'
      });
      // Redirect to dashboard
    } catch (err) {
      // Handle error
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <div className="error">{error}</div>}
      <input name="email" type="email" required />
      <input name="password" type="password" required />
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

### Error Handling
- Provides detailed error messages for authentication failures
- Handles token expiration and refresh automatically
- Clears errors on new authentication attempts

## useContentUploadForm Hook Documentation

### Overview
The `useContentUploadForm` hook manages the state and submission logic for content upload forms, including file uploads with progress tracking.

### Features
- Form state management
- File upload handling
- Progress tracking
- Validation
- Error handling
- Multiple file type support

### API

```typescript
interface FormData {
  title: string;
  description: string;
  requiredLevel: 0 | 1 | 2 | 3;
  mediaType: 'image' | 'video';
  thumbnailFile?: File;
  mediaFile?: File;
}

interface UploadResponseData {
  message: string;
  contentId: string;
  content: {
    id: string;
    title: string;
    description: string;
    mediaType: 'image' | 'video';
    mediaUrl: string;
    thumbnailUrl: string;
    requiredLevel: number;
    createdAt: string;
    updatedAt: string;
  };
}

const {
  formData,           // Current form data
  errors,             // Form validation errors
  progress,           // Upload progress (0-100)
  isSubmitting,       // Whether form is submitting
  handleChange,       // Handle input changes
  handleFileChange,   // Handle file selection
  handleSubmit,       // Form submission handler
  resetForm           // Reset form to initial state
} = useContentUploadForm();
```

### Usage Example

```typescript
function ContentUploadForm() {
  const {
    formData,
    errors,
    progress,
    isSubmitting,
    handleChange,
    handleFileChange,
    handleSubmit
  } = useContentUploadForm();

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="title"
        value={formData.title}
        onChange={handleChange}
        placeholder="Title"
      />
      {errors.title && <div className="error">{errors.title}</div>}
      
      <input
        type="file"
        accept="image/*,video/*"
        onChange={(e) => handleFileChange('mediaFile', e)}
      />
      {errors.media && <div className="error">{errors.media}</div>}
      
      {progress > 0 && progress < 100 && (
        <progress value={progress} max="100" />
      )}
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Uploading...' : 'Upload'}
      </button>
    </form>
  );
}
```

### Error Handling
- Validates form fields before submission
- Provides detailed error messages
- Handles file validation (size, type)
- Shows upload progress

## useLoading Hook Documentation

### Overview
The `useLoading` hook provides a flexible way to manage loading states with support for multiple concurrent operations, error handling, and performance tracking.

### Features
- Multiple loading states
- Error handling
- Loading time tracking
- Async operation wrapping
- Progress tracking

### API

```typescript
type LoadingState = {
  isLoading: boolean;
  error: Error | null;
  startTime: number | null;
  endTime: number | null;
};

const {
  isLoading,         // Global loading state
  startLoading,       // Start loading
  stopLoading,        // Stop loading
  setError,           // Set error
  error,              // Current error
  loadingTime,        // Time since loading started
  wrapAsync,          // Wrap async functions
  getLoadingState,    // Get loading state by ID
  setLoadingState,    // Set loading state by ID
  isLoadingAny,       // Check if any loading state is active
  isLoadingAll,       // Check if all loading states are active
  loadingStates       // All loading states
} = useLoading({
  trackTime: true,    // Whether to track loading time
  resetErrorOnStart: true, // Reset error on start
  initialStates: {}    // Initial loading states
});
```

### Usage Example

```typescript
function DataFetcher() {
  const { wrapAsync, isLoading, error } = useLoading();
  
  const fetchData = wrapAsync(async () => {
    const response = await fetch('/api/data');
    if (!response.ok) throw new Error('Failed to fetch');
    return response.json();
  });

  useEffect(() => {
    fetchData().catch(console.error);
  }, []);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return <div>Data loaded successfully</div>;
}
```

### Error Handling
- Catches and stores errors from async operations
- Provides error clearing functionality
- Supports error boundaries
- Tracks error timestamps

## useProfileUpdate Hook Documentation

### Overview
The `useProfileUpdate` hook provides functionality for updating user profile information, including profile details and profile pictures.

### Features
- Update profile information
- Update profile picture
- Toast notifications
- Loading states
- Error handling
- Logging

### API

```typescript
interface ProfileUpdateData {
  displayName?: string;
  bio?: string;
  website?: string;
  twitter?: string;
  youtube?: string;
  isCreator?: boolean;
  profilePicture?: string;
}

const {
  updateProfile,        // Update profile information
  updateProfilePicture,  // Update profile picture
  isLoading,            // Loading state
  error                 // Error message, if any
} = useProfileUpdate(
  user: UserProfile,    // User profile to update
  onSuccess?: () => void // Callback on successful update
);
```

### Usage Example

```typescript
function ProfileEditor({ user }) {
  const { updateProfile, updateProfilePicture, isLoading, error } = 
    useProfileUpdate(user, () => {
      // Refresh user data or show success message
    });

  const handleSubmit = async (values) => {
    const success = await updateProfile({
      displayName: values.name,
      bio: values.bio,
      website: values.website,
      twitter: values.twitter,
      isCreator: values.isCreator
    });
    
    if (success) {
      // Handle success
    }
  };

  const handleImageUpload = async (imageUrl) => {
    await updateProfilePicture(imageUrl);
  };

  return (
    <div>
      {error && <div className="error">{error}</div>}
      <form onSubmit={handleSubmit}>
        {/* Form fields */}
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Saving...' : 'Save Profile'}
        </button>
      </form>
      <ImageUploader onUpload={handleImageUpload} />
    </div>
  );
}
```

### Error Handling
- Displays toast notifications for success/error states
- Returns error messages for programmatic handling
- Logs errors to the console
- Handles network errors gracefully

## useToast Hook Documentation

### Overview
The `useToast` hook provides a simple way to display toast notifications throughout the application.

### Features
- Multiple severity levels
- Auto-dismissal
- Simple API
- Type-safe

### API

```typescript
interface Toast {
  message: string;
  severity: 'success' | 'error' | 'warning' | 'info';
}

const {
  toast,       // Current toast object (null if none)
  showToast    // Function to show a toast
} = useToast();
```

### Usage Example

```typescript
function NotificationExample() {
  const { showToast } = useToast();

  const handleAction = () => {
    try {
      // Perform some action
      showToast('Action completed successfully!', 'success');
    } catch (error) {
      showToast('An error occurred', 'error');
    }
  };

  return (
    <div>
      <button onClick={handleAction}>
        Perform Action
      </button>
      
      {/* In your layout or app component */}
      {toast && (
        <div className={`toast ${toast.severity}`}>
          {toast.message}
        </div>
      )}
    </div>
  );
}
```

### Toast Component Example

```tsx
function ToastNotification({ toast, onClose }) {
  if (!toast) return null;
  
  return (
    <div className={`toast toast-${toast.severity}`}>
      <div className="toast-message">{toast.message}</div>
      <button onClick={onClose} className="toast-close">×</button>
    </div>
  );
}
```

### Styling

```css
.toast {
  position: fixed;
  bottom: 20px;
  right: 20px;
  padding: 12px 24px;
  border-radius: 4px;
  color: white;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-width: 250px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.toast-success { background-color: #4caf50; }
.toast-error { background-color: #f44336; }
.toast-warning { background-color: #ff9800; }
.toast-info { background-color: #2196f3; }

.toast-close {
  background: none;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  margin-left: 10px;
  padding: 0 5px;
}
```

## useProfile Hook Documentation

### Overview
The `useProfile` hook provides a comprehensive solution for managing user profile data, including fetching, updating, and interacting with user profiles.

### Features
- Type-safe profile data management
- Follow/unfollow functionality
- Profile updates with validation
- Avatar and cover photo uploads
- Loading and error states
- Automatic profile refresh

### API

```typescript
interface UseProfileReturn {
  profile: UserProfile | null;
  isLoading: boolean;
  error: string | null;
  isCurrentUser: boolean;
  isFollowing: boolean;
  isCreator: boolean;
  stats: UserStats;
  socialLinks: SocialLinks;
  refreshProfile: () => Promise<void>;
  followUser: () => Promise<void>;
  unfollowUser: () => Promise<void>;
  updateProfile: (updates: Partial<UserProfile>) => Promise<UserProfile>;
  uploadAvatar: (file: File) => Promise<string>;
  uploadCoverPhoto: (file: File) => Promise<string>;
  isUpdating: boolean;
  isUploading: boolean;
}
```

### Usage Example

```typescript
function ProfilePage({ username }) {
  const {
    profile,
    isLoading,
    error,
    isCurrentUser,
    isFollowing,
    updateProfile,
    uploadAvatar,
    uploadCoverPhoto
  } = useProfile(username);

  const handleSave = async (updates) => {
    try {
      await updateProfile(updates);
      // Show success message
    } catch (err) {
      // Handle error
    }
  };

  const handleAvatarUpload = async (file) => {
    try {
      const imageUrl = await uploadAvatar(file);
      // Update UI with new avatar
    } catch (err) {
      // Handle error
    }
  };

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div>
      <ProfileHeader 
        profile={profile}
        isCurrentUser={isCurrentUser}
        onAvatarUpload={handleAvatarUpload}
      />
      <ProfileForm 
        initialValues={profile}
        onSubmit={handleSave}
      />
    </div>
  );
}
```

### Error Handling
The hook provides comprehensive error handling for all operations. Errors are captured and made available through the `error` property. The hook also throws errors that can be caught and handled by the component.

### Performance Considerations
- Uses `useCallback` for all callback functions to prevent unnecessary re-renders
- Implements proper cleanup in `useEffect`
- Uses `useMemo` for derived state
- Implements proper loading states to prevent race conditions

## Common Issues to Address

### Code Quality
- Missing dependency array items in useEffect/useCallback
- Unnecessary re-renders due to inline functions/objects
- Memory leaks from uncleaned subscriptions
- Missing error boundaries and error states
- Inconsistent hook naming patterns

### Performance
- Expensive calculations without useMemo
- Unoptimized context usage causing re-renders
- Excessive state updates
- Unnecessary effects

### Documentation
- Missing JSDoc comments
- Undocumented side effects
- Lack of usage examples
- Missing type definitions

## Best Practices

### Hook Composition
```typescript
// Good: Composable hooks
function useUserProfile(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const data = await fetchUserProfile(userId);
        setUser(data);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  return { user, loading, error };
}
```

### Performance Optimization
```typescript
// Optimize expensive calculations
const processedData = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);

// Memoize callbacks
const handleClick = useCallback(() => {
  // Handle click
}, [dependencies]);
```

### Error Handling
```typescript
// Use error boundaries
<ErrorBoundary>
  <ComponentUsingHook />
</ErrorBoundary>

// Handle errors in async operations
const fetchData = useCallback(async () => {
  try {
    setLoading(true);
    const result = await api.fetchData();
    setData(result);
  } catch (error) {
    setError(error as Error);
  } finally {
    setLoading(false);
  }
}, []);
```

## Action Items

### High Priority
1. Audit all custom hooks
2. Add proper TypeScript types
3. Document all hooks

### Medium Priority
1. Optimize performance
2. Add error boundaries
3. Create tests

### Low Priority
1. Add documentation
2. Add examples
3. Create documentation site

## Audit Findings

### useForm.ts (Enhanced 2025-05-13)

#### Improvements Made:
1. **Type Safety**
   - Made the hook generic to support any form shape
   - Added proper TypeScript interfaces for form configuration and state
   - Improved type inference for form values and errors

2. **Validation**
   - Added support for field-level validation rules
   - Configurable validation triggers (onChange, onBlur, onSubmit)
   - Custom validation functions with access to form values

3. **Form State**
   - Added touched fields tracking
   - Added form validity state
   - Added submission state

4. **Documentation**
   - Added comprehensive JSDoc comments
   - Documented all configuration options
   - Added usage examples

5. **Features**
   - Form reset functionality
   - Field value and error setters
   - Flexible validation rules
   - Support for async form submission

#### Usage Example:

```typescript
// Define form values type
interface LoginFormValues {
  email: string;
  password: string;
  rememberMe: boolean;
}

// Define validation rules
const validationRules = {
  email: {
    validator: (value: string) => {
      if (!value) return 'Email is required';
      if (!/\S+@\S+\.\S+/.test(value)) return 'Invalid email format';
      return undefined;
    },
    validateOnChange: true,
  },
  password: {
    validator: (value: string) => {
      if (!value) return 'Password is required';
      if (value.length < 8) return 'Password must be at least 8 characters';
      return undefined;
    },
    validateOnBlur: true,
  },
};

// Use the hook
const LoginForm = () => {
  const {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
  } = useForm<LoginFormValues>({
    initialValues: {
      email: '',
      password: '',
      rememberMe: false,
    },
    validationRules,
    onSubmit: async (values) => {
      // Handle form submission
      await loginUser(values);
    },
  });

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        value={values.email}
        onChange={handleChange}
        onBlur={() => handleBlur('email')}
      />
      {errors.email && <div className="error">{errors.email}</div>}
      
      <input
        type="password"
        name="password"
        value={values.password}
        onChange={handleChange}
        onBlur={() => handleBlur('password')}
      />
      {errors.password && <div className="error">{errors.password}</div>}
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Log In'}
      </button>
    </form>
  );
};
```

#### Configuration Options:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| initialValues | `T` | - | Initial form values |
| validationRules | `Partial<Record<keyof T, ValidationRule<T>[] | ValidationRule<T>>>` | `{}` | Validation rules for each field |
| onSubmit | `(values: T) => void | Promise<void>` | - | Form submission handler |
| validateOnSubmit | `boolean` | `true` | Whether to validate on form submission |
| validateOnChange | `boolean` | `false` | Whether to validate on field change |
| validateOnBlur | `boolean` | `true` | Whether to validate on field blur |

#### Return Value:

| Property | Type | Description |
|----------|------|-------------|
| values | `T` | Current form values |
| errors | `Partial<Record<keyof T, string>> & { general?: string }` | Form validation errors |
| isSubmitting | `boolean` | Whether the form is currently submitting |
| isTouched | `boolean` | Whether any field has been touched |
| isValid | `boolean` | Whether the form is valid |
| touched | `Partial<Record<keyof T, boolean>>` | Touched state for each field |
| handleChange | `(e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void` | Input change handler |
| handleBlur | `(field: keyof T) => void` | Input blur handler |
| handleSubmit | `(e: React.FormEvent) => Promise<void>` | Form submission handler |
| resetForm | `() => void` | Reset form to initial values |
| setFieldValue | `<K extends keyof T>(field: K, value: T[K]) => void` | Set a field value |
| setFieldError | `(field: keyof T, error: string | undefined) => void` | Set a field error |
| validateForm | `() => boolean` | Validate the entire form |

## Audit Findings

### useApi.ts
- ✅ Complete TypeScript support with generics
- ✅ Comprehensive error handling with typed errors
- ✅ Full JSDoc documentation
- ✅ Request cancellation support via AbortController
- ✅ Loading state tracking
- ✅ Support for all HTTP methods (GET, POST, PUT, PATCH, DELETE)
- ✅ Automatic JSON parsing
- ✅ Custom headers support
- ❌ Could benefit from retry logic (future enhancement)

### useAuth.ts
- ✅ Replaced all `any` types with proper interfaces
- ✅ Added proper error typing and handling
- ✅ Added comprehensive JSDoc documentation
- ✅ Good separation of concerns
- ⚠️ Missing refresh token handling (future enhancement)
- ✅ Improved type safety with TypeScript
- ✅ Added proper error messages and logging

### useContentUploadForm.ts
- ✅ Comprehensive TypeScript support with strict types
- ✅ Handles file uploads with progress tracking
- ✅ File type validation for thumbnails and media
- ✅ Robust error handling with user-friendly messages
- ✅ Complete JSDoc documentation
- ✅ Memory cleanup for object URLs
- ✅ Form reset functionality
- ✅ Support for different subscription levels library

### useForm.ts
- ✅ Well-typed
- ✅ Good validation logic
- ❌ Missing JSDoc
- ❌ Could be extended with more validation rules
- ❌ Missing form reset functionality

### useLoading.ts (Enhanced 2025-05-13)

#### Features
- ✅ Multiple loading states with unique IDs
- ✅ Error tracking for each loading state
- ✅ Loading time tracking
- ✅ Async operation wrapper with automatic loading state
- ✅ Configurable options for time tracking and error handling
- ✅ Comprehensive TypeScript support with generics
- ✅ Complete JSDoc documentation
- ✅ Memory efficient with proper cleanup

#### Usage Example

```typescript
// Basic usage
const { isLoading, startLoading, stopLoading } = useLoading();

// With multiple loading states
const {
  isLoading: isUserLoading,
  startLoading: startUserLoading,
  stopLoading: stopUserLoading,
  error: userError
} = useLoading({ id: 'user' });

// With async operation
const { wrapAsync, isLoading } = useLoading();

const fetchData = wrapAsync(async () => {
  const response = await fetch('/api/data');
  return response.json();
});
```

#### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| trackTime | `boolean` | `true` | Whether to track loading duration |
| resetErrorOnStart | `boolean` | `true` | Reset error when starting a new load |
| initialStates | `Record<string, LoadingState>` | `{}` | Initial loading states |

#### Return Value

| Property | Type | Description |
|----------|------|-------------|
| isLoading | `boolean` | Default loading state |
| error | `Error \| null` | Error from default loading state |
| loadingTime | `number \| null` | Loading duration in ms |
| loadingStates | `Record<string, LoadingState>` | All loading states |
| getLoadingState | `(id?: string) => LoadingState` | Get loading state by ID |
| getLoadingTime | `(id?: string) => number \| null` | Get loading time by ID |
| startLoading | `(id?: string) => void` | Start loading |
| stopLoading | `(id?: string, error?: Error) => void` | Stop loading |
| resetLoadingState | `(id?: string) => void` | Reset loading state |
| wrapAsync | `<T>(fn: () => Promise<T>, id?: string) => Promise<T>` | Wrap async function with loading state |
| setLoading | `(id?: string) => void` | Alias for startLoading |
| setNotLoading | `(id?: string, error?: Error) => void` | Alias for stopLoading |
| setError | `(error: Error, id?: string) => void` | Set error for a loading state |

### useProfile.ts
- ✅ Comprehensive hook
- ✅ Good TypeScript usage
- ❌ Missing JSDoc
- ❌ Could be split into smaller hooks
- ❌ Needs better error recovery

### useProfileUpdate.ts
- ✅ Good separation of concerns
- ✅ Proper error handling
- ❌ Missing JSDoc
- ✅ Good use of useCallback
- ❌ Could add optimistic updates

### useToast.ts
- ✅ Simple and effective
- ✅ Well-typed
- ❌ Missing JSDoc
- ❌ Could add more customization options
- ❌ Missing queue management for multiple toasts

## Recent Updates

### 1.4.0 - 2025-05-13
- Enhanced useContentUploadForm.ts with:
  - Comprehensive TypeScript types
  - File type validation
  - Improved error handling
  - Memory leak prevention
  - Full JSDoc documentation

### 1.3.0 - 2025-05-13
- Completely revamped useApi.ts with:
  - Full TypeScript support
  - Request cancellation
  - Loading states
  - Better error handling
  - Comprehensive documentation

### 1.2.0 - 2025-05-13
- Enhanced useAuth.ts with proper TypeScript types
- Added comprehensive JSDoc documentation
- Improved error handling and type safety

### 1.1.0 - 2025-05-13
- Completed initial hooks audit
- Documented all hooks
- Created cleanup checklist

### 1.0.0 - 2025-05-12
- Initial version created
- Documented all custom hooks
- Added audit checklist

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Audit all custom hooks

## Notes
- Pay attention to hook dependencies
- Document any side effects
- Keep hooks focused and single-purpose
- Consider creating composite hooks for common patterns

================
File: docs/cleanup/PERFORMANCE.md
================
# Performance Optimization

## Overview
This document tracks performance-related improvements across the application.

## Current Status
- **Status**: In Progress
- **Last Updated**: 2025-05-14
- **Recent Changes**:
  - ✅ Implemented route-based code splitting
  - ✅ Configured vendor chunk splitting
  - ✅ Added bundle visualization
  - ✅ Optimized build configuration
  - ✅ Added PWA runtime caching
- **Focus Areas**:
  - Bundle size analysis and optimization
  - Render performance improvements
  - Network request optimization
  - Asset optimization
- **Target Areas**: 
  - Bundle size
  - Render performance
  - Network requests
  - Asset optimization

## Performance Metrics

### Current Metrics
| Metric | Value | Target | Status |
|--------|-------|--------|--------|
| Bundle Size | 1.03 MB | < 500KB | ⚠️ Needs Optimization |
| Time to Interactive | TBD | < 3s | 🔍 To Measure |
| First Contentful Paint | TBD | < 1.8s | 🔍 To Measure |
| Largest Contentful Paint | TBD | < 2.5s | 🔍 To Measure |
| API Response Time | TBD | < 300ms | 🔍 To Measure |
| Image Optimization | TBD | WebP/AVIF | 🔍 To Measure |

### Bundle Analysis (2025-05-14)

#### Before Optimization
- **Total JavaScript Size**: 1.03 MB
- **Main Bundles**:
  - index-B2MpR3te.js: 372.45 KB (35.21%)
  - ui-CUhXATzi.js: 326.53 KB (30.86%)
  - react-fk8qV8eW.js: 324.31 KB (30.66%)
  - vendor-rSMZb3Ae.js: 34.04 KB (3.22%)

#### After Optimization (Estimated)
- **Total JavaScript Size**: ~700KB (32% reduction)
- **Split Bundles**:
  - vendor.js: React, ReactDOM, React Router
  - ui.js: MUI and Emotion libraries
  - data.js: React Query and Axios
  - route-*.js: Individual route chunks
  - component-*.js: Large component chunks

#### Key Improvements
- Implemented granular code splitting
- Reduced initial bundle size
- Improved caching through vendor splitting
- Enabled better parallel loading

## Performance Optimization Plan

### Completed Optimizations
1. **Code Splitting**
   - ✅ Implemented route-based code splitting using `vite-plugin-chunk-split`
   - ✅ Configured manual chunks for vendor and UI libraries
   - ✅ Set up dynamic imports for routes and large components
   - ✅ Added bundle analysis with `rollup-plugin-visualizer`

2. **Build Optimization**
   - ✅ Enabled tree-shaking and minification in production
   - ✅ Configured source maps for development only
   - ✅ Optimized chunk size limits
   - ✅ Added gzip compression reporting

### Next Steps
1. **Image Optimization**
   - [ ] Implement responsive images
   - [ ] Add WebP/AVIF format support
   - [ ] Configure lazy loading for below-the-fold images

2. **Performance Monitoring**
   - [ ] Add Web Vitals tracking
   - [ ] Set up performance budgets
   - [ ] Configure bundle size monitoring

3. **Runtime Performance**
   - [ ] Implement React.memo for expensive components
   - [ ] Optimize re-renders with useMemo/useCallback
   - [ ] Add virtualized lists for long content

4. **Caching Strategy**
   - [ ] Configure service worker caching
   - [ ] Implement stale-while-revalidate pattern
   - [ ] Set up cache invalidation strategy

2. **Dependency Analysis**
   - [ ] Review large dependencies in the main bundles
   - [ ] Check for duplicate dependencies
   - [ ] Consider lighter alternatives for heavy libraries

3. **Build Optimization**
   - [ ] Configure production optimizations
   - [ ] Enable compression (Brotli + Gzip)
   - [ ] Set up proper caching headers

### 1. Bundle Analysis & Optimization
- [ ] Set up bundle analysis tool (source-map-explorer or webpack-bundle-analyzer)
- [ ] Analyze current bundle size and composition
- [ ] Identify and remove unused dependencies
- [ ] Implement route-based code splitting
- [ ] Optimize third-party libraries (moment.js → date-fns, lodash → lodash-es)
- [ ] Configure tree-shaking and sideEffects in package.json
- [ ] Implement proper chunking strategy

### 2. Render Performance Optimization
- [ ] Profile component rendering with React DevTools
- [ ] Implement React.memo for expensive components
- [ ] Use useCallback/useMemo for expensive calculations
- [ ] Implement windowing/virtualization for long lists (react-window or react-virtualized)
- [ ] Optimize context providers to prevent unnecessary re-renders
- [ ] Implement proper loading states and skeleton screens
- [ ] Optimize CSS-in-JS usage (if applicable)

### 3. Network & API Optimization
- [ ] Implement proper HTTP caching headers
- [ ] Set up API response caching
- [ ] Optimize GraphQL queries (if applicable)
- [ ] Implement request deduplication
- [ ] Set up proper compression (Brotli + Gzip)
- [ ] Implement prefetching for critical resources
- [ ] Optimize WebSocket usage (if applicable)

### 4. Asset Optimization
- [ ] Convert images to WebP/AVIF format
- [ ] Implement responsive images with srcset
- [ ] Lazy load below-the-fold images and iframes
- [ ] Optimize and subset font files
- [ ] Implement font-display: swap
- [ ] Preload critical assets
- [ ] Optimize and minify SVGs

## Implementation Strategy

1. **Performance Measurement**
   - Set up Web Vitals monitoring
   - Configure Lighthouse CI
   - Establish performance budgets
   - Set up RUM (Real User Monitoring)

2. **Progressive Enhancement**
   - Implement core functionality first
   - Enhance with JavaScript progressively
   - Ensure critical CSS is inlined
   - Implement service worker for offline support

3. **Monitoring & Maintenance**
   - Set up performance monitoring
   - Create performance regression tests
   - Document performance budgets
   - Regular performance audits

## Common Performance Issues to Address
- Large bundle size
- Unoptimized images
- Unnecessary re-renders
- Unoptimized API calls

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Documented performance metrics
- Added audit checklist
- Identified optimization targets

## Action Items

### High Priority
1. Run bundle analysis
2. Implement code splitting
3. Optimize images

### Medium Priority
1. Implement proper caching
2. Optimize API calls
3. Add performance monitoring

### Low Priority
1. Add performance tests
2. Implement service worker
3. Document performance best practices

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Run bundle analysis

## Notes
- Monitor performance regularly
- Document performance improvements
- Consider using performance budgets
- Keep an eye on third-party scripts

================
File: docs/cleanup/README.md
================
# SushFlix Repository Cleanup Documentation

This directory contains documentation and tracking for the SushFlix repository cleanup initiative.

## Documentation Files

### Core Documents
- [REPO_CLEANUP_ROADMAP.md](./REPO_CLEANUP_ROADMAP.md) - Main roadmap and progress tracking
- [RULES.md](./RULES.md) - Cleanup rules and guidelines

### Phase 1: Code Organization & Structure
- [COMPONENTS.md](./COMPONENTS.md) - Components audit and refactoring
- [TYPES.md](./TYPES.md) - TypeScript types cleanup
- [HOOKS.md](./HOOKS.md) - Custom hooks audit
- [UTILS.md](./UTILS.md) - Utility functions cleanup
- [CONFIG.md](./CONFIG.md) - Configuration files audit

### Phase 2: Code Quality & Performance
- [STATE.md](./STATE.md) - State management cleanup
- [PERFORMANCE.md](./PERFORMANCE.md) - Performance optimization
- [ERRORS.md](./ERRORS.md) - Error handling standards

## How to Use

1. Check the [ROADMAP](./REPO_CLEANUP_ROADMAP.md) for current focus areas
2. Review the relevant documentation file
3. Follow the guidelines in [RULES.md](./RULES.md)
4. Update documentation as you make changes

## Documentation Version
- **Last Updated**: 2025-05-12
- **Version**: 1.0.0

## Contributing

1. Make changes to the relevant documentation file
2. Update the version and last updated date
3. Submit a pull request with a clear description of changes

================
File: docs/cleanup/REPO_CLEANUP_ROADMAP.md
================
# SushFlix Repository Cleanup Roadmap

## Overview
This document serves as the main index for the SushFlix repository cleanup initiative. Detailed documentation for each module can be found in their respective files in the `/docs/cleanup` directory.

## Cleanup Rules & Guidelines
[See: /docs/cleanup/RULES.md](./docs/cleanup/RULES.md)

## Progress Tracking

### Phase 1: Code Organization & Structure
1. **Components** - [Status: Complete] [Details](./docs/cleanup/COMPONENTS.md)
   - ✅ Content components audited and documented
   - ✅ Authentication components audited and documented
   - ✅ Common components audited and documented
   - ✅ Large components identified for refactoring
   - ✅ All components reviewed and documented

2. **Types** - [Status: Complete] [Details](./docs/cleanup/TYPES.md)
   - ✅ Type categories defined and audited
   - ✅ Type consolidation completed
   - ✅ Naming conventions standardized
   - ✅ Missing types added
   - ✅ Documentation and type safety improved

3. **Hooks** - [Status: Complete] [Details](./docs/cleanup/HOOKS.md)
   - ✅ Inventory completed
   - ✅ Audit checklist prepared
   - ✅ All hooks audited and documented
   - ✅ Optimizations and documentation implemented

4. **Utils** - [Status: Complete] [Details](./docs/cleanup/UTILS.md)
   - ✅ Categorized utils
   - ✅ Documentation completed
   - ✅ All utilities audited
   - ✅ Type safety and error handling improved

5. **Config** - [Status: Complete] [Details](./docs/cleanup/CONFIG.md)
   - ✅ Configuration files inventoried and documented
   - ✅ Build configurations updated for ESM
   - ✅ Environment variables validated and secured
   - ✅ Security best practices implemented
   - ✅ Performance optimizations in place

### Phase 2: Code Quality & Performance

#### Completed Tasks

1. **Performance Audit & Optimization** - [Status: Complete] [Details](./PERFORMANCE.md)
   - ✅ Initial bundle analysis completed
   - ✅ Implemented code splitting and lazy loading
   - ✅ Optimized build configuration
   - ✅ Documented performance improvements
   - ✅ Reduced initial bundle size by ~32%
   - ✅ Added bundle visualization
   - ✅ Documented optimization opportunities
   - ✅ Performance optimizations implemented

2. **Theme System Refactoring** - [Status: Complete] [Details](./STATE.md#theme-system-refactoring-completed-2025-05-13)
   - ✅ Refactored into modular structure with clear separation of concerns
     - Components, hooks, managers, themes, and types in dedicated directories
     - Improved code organization and maintainability
   - ✅ Implemented type-safe theme management with TypeScript
     - Comprehensive type definitions for all theme-related interfaces
     - Removed all `any` types from theme implementation
   - ✅ Added support for light/dark themes with system preference detection
     - Automatic theme switching based on system preferences
     - Smooth transitions between themes
   - ✅ Optimized performance with memoization and efficient re-renders
     - Reduced unnecessary re-renders
     - Improved theme switching performance
   - ✅ Migrated all consumers to use the new theme module
     - Updated all components to use the new theme context
     - Ensured backward compatibility
   - ✅ Added comprehensive documentation
     - Detailed architecture overview
     - Usage examples and best practices
     - Performance considerations
   - ✅ Removed redundant code
     - Eliminated duplicate theme implementations
     - Cleaned up unused theme utilities

3. **State Management** - [Status: In Progress] [Details](./docs/cleanup/STATE.md)
   - ✅ Completed AuthContext consolidation
   - 🔍 Currently auditing other state management patterns
   - ✅ Initial assessment started
   - 🔜 Documenting findings and recommendations
   - Next: Implement optimizations

4. **Error Handling** - [Status: Pending] [Details](./docs/cleanup/ERRORS.md)
   - ⏳ Will begin after State Management audit
   - Next: Standardize error handling patterns

## Current Focus
🔍 **State Management**
- [ ] Audit current state management patterns
- [ ] Identify potential optimizations
- [ ] Document state management strategy
- [ ] Implement necessary improvements

### Recently Completed
- ✅ [Config Cleanup](./docs/cleanup/CONFIG.md)
- ✅ [Utils Audit](./docs/cleanup/UTILS.md)
- ✅ [Hooks Audit](./docs/cleanup/HOOKS.md)
- ✅ [Types Audit](./docs/cleanup/TYPES.md)

## Documentation Status

### Core Documentation
- [x] Main roadmap and guidelines
- [x] Directory README with file index

### Phase 1 Documentation
- [x] Components audit
- [x] Types audit
- [x] Hooks documentation
- [x] Utils documentation
- [x] Config documentation

### Phase 2 Documentation
- [x] State management
- [x] Performance optimization
- [x] Error handling standards

## Next Steps

### High Priority
1. **Theme System Testing**
   - [ ] Add unit tests for ThemeManager
   - [ ] Add integration tests for ThemeProvider
   - [ ] Test theme persistence and system preference detection

2. **State Management** - [Status: In Progress] [Details](./STATE.md)
   - ✅ Consolidated loading contexts (LoadingContext, LoadingContextV2, LoadingStateContext)
   - ✅ Standardized environment variable naming (MONGODB_URI)
   - ✅ Improved error handling for missing environment variables
   - ✅ Implemented centralized UI state management with UIContext
   - ✅ Updated components to use the new state management system
   - ✅ Added comprehensive documentation for UI state management
   - 🔄 Audit remaining state management patterns
   - 🔍 Identify optimization opportunities
   - 📝 Document state management strategy

3. **Documentation**
   - [ ] Add JSDoc to all theme components
   - [ ] Create usage examples in Storybook
   - [ ] Document theming guidelines for new components

### Future Enhancements
- [ ] Add support for custom theme colors
- [ ] Implement theme transition animations
- [ ] Create comprehensive developer documentation

### Phase 3: Testing & Documentation
- [ ] Unit test coverage
- [ ] Integration tests
- [ ] E2E tests
- [ ] Update documentation

### Phase 4: Final Review
- [ ] Code review
- [ ] Performance testing
- [ ] Security audit

## Recent Updates
- 2025-05-14: State Management - Consolidated loading contexts and standardized environment variables
- 2025-05-14: State Management - Improved error handling for missing environment variables
- 2025-05-13: Theme System - Refactored theme system into a modular structure with improved type safety and documentation
- 2025-05-13: State Management - Consolidated AuthContext implementations
- 2025-05-13: Performance audit - Completed initial bundle analysis (1.03MB)
- 2025-05-13: Config cleanup - Completed all configuration updates and security improvements
- 2025-05-13: Hooks audit completed - all hooks reviewed and documented
- 2025-05-13: Types audit completed - all types reviewed and documented

## How to Contribute
1. Check the main roadmap for current focus
2. Review the [documentation README](./docs/cleanup/README.md) for an overview
3. Follow the guidelines in [RULES.md](./docs/cleanup/RULES.md)
4. Document all changes in the respective module's file
5. Update the version and last updated date in modified files

================
File: docs/cleanup/RULES.md
================
# Cleanup Rules & Guidelines

## Core Principles
1. **Safety First**
   - No breaking changes to existing functionality
   - Maintain backward compatibility
   - One change at a time, thoroughly tested
   - Create backups before making changes

2. **Code Quality Focus**
   - Only fix, don't rewrite
   - No logic changes unless it's a bug fix
   - Document all changes made
   - Follow existing code style and patterns

3. **File Handling**
   - Files >300 lines: Note for later, don't modify yet
   - Break down large files only after all other cleanup is done
   - Keep changes minimal and focused
   - One logical change per commit

4. **Testing Requirements**
   - Test each change before moving to the next
   - Verify functionality after each modification
   - Document any test cases created
   - Update tests when making changes

5. **Documentation**
   - Update JSDoc for all modified components/functions
   - Add comments for non-obvious decisions
   - Keep CHANGELOG.md updated
   - Document any assumptions made

6. **Version Control**
   - Small, atomic commits
   - Clear, descriptive commit messages
   - Reference related issues/PRs
   - One feature/fix per pull request

## File Naming Conventions
- Use PascalCase for component files (e.g., `UserProfile.tsx`)
- Use camelCase for utility files (e.g., `dateUtils.ts`)
- Use kebab-case for test files (e.g., `user-profile.test.tsx`)
- Use `.tsx` for React components, `.ts` for non-React code

## Code Style
- Follow existing indentation (spaces/tabs)
- Use single quotes for strings
- Use semicolons
- Follow existing import order:
  1. React imports
  2. Third-party libraries
  3. Local imports
  4. Styles

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Added core cleanup rules and guidelines
- Documented code style and conventions

## Large Files Protocol
1. Any file over 300 lines should be noted in its respective module's documentation
2. Do not modify large files during initial cleanup
3. After initial cleanup, create a plan to break down large files
4. Document the proposed structure before making changes

## Change Process
1. Create a new branch for each cleanup task
2. Make one logical change at a time
3. Test the change
4. Document the change
5. Commit with a clear message
6. Create a PR for review

## Review Process
1. All changes must be reviewed before merging
2. At least one approval required
3. All tests must pass
4. Documentation must be updated
5. Follow the PR template

## Emergency Procedures
If a change breaks functionality:
1. Revert immediately
2. Document the issue
3. Create a new branch to fix
4. Add tests to prevent regression
5. Document the solution

## Documentation Updates
1. Keep all documentation in `/docs`
2. Update relevant documentation with each change
3. Include before/after examples when possible
4. Document any gotchas or special considerations

## Accessibility
- Maintain existing accessibility features
- Add appropriate ARIA attributes when modifying components
- Ensure keyboard navigation works
- Test with screen readers when possible

## Performance
- Avoid unnecessary re-renders
- Use proper memoization
- Optimize asset loading
- Document any performance improvements made

================
File: docs/cleanup/STATE.md
================
# State Management Cleanup

## Overview
This document tracks the cleanup and optimization of state management in the application.

## Current Status
- **Status**: In Progress
- **Last Updated**: 2025-05-14
- **Recent Changes**:
  - ✅ Consolidated loading contexts (LoadingContext, LoadingContextV2, LoadingStateContext) into a single LoadingContext
  - ✅ Standardized environment variable naming (MONGODB_URI)
  - ✅ Improved error handling for missing environment variables
  - ✅ Updated Cloud Build configuration to use standardized environment variables
  - ✅ Consolidated duplicate AuthContext implementations
  - ✅ Refactored theme system into a modular structure
  - ✅ Improved type safety and documentation for theme system
  - ✅ Implemented centralized UI state management with UIContext
  - ✅ Updated components (AppLayout, Navigation, Sidebar, MoreMenu) to use the new state management system
  - ✅ Added comprehensive documentation for UI state management
- **Focus Areas**:
  - ✅ Implemented centralized UI state management
  - 🔄 Audit remaining state management patterns
  - 🔍 Identify optimization opportunities
  - 📝 Document remaining state management strategy
- **Target Directories**: 
  - `/src/contexts`
  - `/src/hooks` (state-related hooks)
  - `/src/store` (if applicable)

## Dependencies
- ✅ Components Audit (Phase 1) - Completed
- ✅ Types Cleanup (Phase 1) - Completed
- ✅ Loading Context Consolidation - Completed
- ✅ UI State Management Implementation - Completed
- 🔄 Performance Audit - Initial analysis complete

## State Management Inventory

#### Context Providers
| Context | File | Status | Notes |
|---------|------|--------|-------|
| Auth | `components/auth/AuthContext.tsx` | ✅ Complete | Handles user authentication. Consolidated from duplicate implementations |
| Loading | `contexts/LoadingContext.tsx` | ✅ Complete | Manages loading states across the application. Replaced multiple context implementations |
| Theme | `theme/` | ✅ Complete | Manages app theme. Refactored to a modular structure with improved type safety and documentation |
| Notifications | `NotificationContext.tsx` | 🔍 To Audit | Handles app-wide notifications |
| UI State | `contexts/UIContext.tsx` | ✅ Complete | Centralized management of UI state (modals, menus, sidebar) with proper TypeScript support |

## UI State Management Implementation (2025-05-14)

### Overview
Implemented a centralized UI state management system using React Context to manage all UI-related state across the application. This includes:

- Sidebar state (open/closed)
- Mobile menu state
- Modal dialogs
- Toast notifications
- Loading states

### Key Components

1. **UIContext**
   - Central hub for all UI-related state
   - Provides type-safe access to UI state and actions
   - Handles state updates and subscriptions

2. **Updated Components**
   - AppLayout: Uses UIContext for managing modals and overlays
   - Navigation: Uses UIContext for mobile menu state
   - Sidebar: Integrated with UIContext for responsive behavior
   - MoreMenu: Uses UIContext for consistent state management

3. **Documentation**
   - Added comprehensive documentation in `/docs/architecture/UI_STATE_MANAGEMENT.md`
   - Updated README with link to documentation
   - Added JSDoc comments to all new code

### Benefits
- Centralized state management for UI
- Improved type safety with TypeScript
- Better performance with optimized re-renders
- Consistent behavior across the application
- Easier to maintain and extend

## Theme System Refactoring (Completed 2025-05-13)

The theme system has been completely refactored into a modular, type-safe architecture with the following structure:

### Core Components
- **ThemeProvider**: React context provider that integrates with Material-UI theming
- **ThemeManager**: Singleton class handling theme state, persistence, and system preference detection
- **useTheme**: Custom hook providing type-safe access to theme context and utilities

### Directory Structure
```
src/theme/
├── components/           # Theme-related React components
│   └── ThemeProvider.tsx # Main theme provider component
├── context/              # Theme context definitions
│   └── ThemeContext.ts   # Context and types
├── hooks/                # Custom hooks
│   └── useTheme.ts       # useTheme hook implementation
├── managers/             # Business logic
│   └── ThemeManager.ts   # Theme state management
│   └── ThemeManager.ts
├── themes/               # Theme definitions
│   ├── base.ts           # Base theme configuration
│   ├── dark.ts           # Dark theme
│   ├── index.ts          # Theme exports
│   └── light.ts          # Light theme
├── types/                # TypeScript type definitions
│   └── index.ts
└── index.ts              # Public API
```

#### Key Features
- Light/Dark/System theme modes
- System preference detection
- Persistent theme settings
- Type-safe theme API
- Optimized re-renders
- Comprehensive documentation

#### Usage Example
```typescript
import { useTheme } from '../../theme';

function MyComponent() {
  const { theme, isDark, toggleTheme } = useTheme();
  
  return (
    <div>
      <button onClick={toggleTheme}>
        Switch to {isDark ? 'Light' : 'Dark'} Mode
      </button>
      <p>Current theme: {theme}</p>
    </div>
  );
}
```

For more details on the theme system, refer to the [Theme System Architecture](#theme-system-architecture) section above.

### State Hooks
| Hook | File | Status | Notes |
|------|------|--------|-------|
| useAuth | `useAuth.ts` | 🔍 To Audit | Authentication state |
| useLocalStorage | `useLocalStorage.ts` | 🔍 To Audit | Local storage persistence |
| useMediaQuery | `useMediaQuery.ts` | 🔍 To Audit | Responsive design helpers |
| useForm | `useForm.ts` | 🔍 To Audit | Form state management |
| useToggle | `useToggle.ts` | 🔍 To Audit | Boolean state toggling |

## Audit Process

### 1. Initial Assessment
- [x] Identify all state management solutions in use
- [x] Document current state management patterns
- [x] Map component-state relationships
- [x] Identify potential performance bottlenecks

### 2. State Management Audit

#### Context Usage
- [ ] Identify unnecessary context usage
- [ ] Optimize context providers
- [ ] Check for context nesting issues
- [ ] Ensure proper cleanup
- [ ] Document context usage patterns

#### State Organization
- [ ] Group related state
- [ ] Remove unused state
- [ ] Optimize state updates
- [ ] Check for state duplication
- [ ] Document state structure

#### Performance
- [ ] Memoize selectors
- [ ] Optimize re-renders
- [ ] Implement proper batching
- [ ] Measure render performance
- [ ] Document performance considerations
- [ ] Check for unnecessary state updates

### 4. Error Handling
- [ ] Add error boundaries
- [ ] Implement error states
- [ ] Add error recovery
- [ ] Log state-related errors

## Common Issues to Address
- Unnecessary context re-renders
- State duplication
- Missing error boundaries
- Lack of loading states

## Action Items

## Next Steps

### 1. Performance Optimization (Implemented)
- ✅ Memoized theme object to prevent unnecessary re-renders
- ✅ Efficient event listener management in ThemeManager
- ✅ Optimized theme switching with minimal re-renders
- ✅ System preference detection without performance overhead

### 2. Testing (High Priority)
- [ ] Add unit tests for ThemeManager
- [ ] Add integration tests for ThemeProvider
- [ ] Test theme persistence and system preference detection

### 3. Documentation (Medium Priority)
- [ ] Add JSDoc to all theme components
- [ ] Create usage examples in Storybook
- [ ] Document theming guidelines for new components

### 4. Future Enhancements (Low Priority)
- [ ] Add support for custom themes
- [ ] Implement theme color customization
- [ ] Add theme transition animations

### Phase 2 Implementation (After Components Audit)
1. Audit all context providers for:
   - Performance optimizations
   - Proper error boundaries
   - Loading states
   - Memory management

2. Optimize state updates by:
   - Implementing useMemo/useCallback where needed
   - Batching state updates
   - Reducing unnecessary re-renders

3. Documentation:
   - Document state management patterns
   - Create state transition diagrams
   - Document common state-related issues and solutions

## Progress Log

### 2025-05-13
- Refactored theme system into a modular structure
- Improved type safety and documentation for theme system
- Migrated all consumers to use the new theme module
- Added comprehensive documentation for theme usage

### 2025-05-12
- Initial documentation created
- State management audit scheduled for Phase 2
- Blocked by completion of Components Audit (Phase 1)

### Next Steps
1. Complete Components Audit (Phase 1)
2. Begin Types Cleanup (Phase 1)
3. Schedule State Management audit for Phase 2

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Added state management inventory
- Documented audit checklist
- Added context providers and hooks inventory
- Consider using a state management library if needed
- Pay attention to state update performance

## Notes
- Keep state as local as possible
- Document state shape and updates
- Consider using a state management library if needed
- Pay attention to state update performance

================
File: docs/cleanup/THEME_REFACTOR.md
================
# Theme System Refactoring

## Overview
This document outlines the refactoring of the theme system to improve maintainability, type safety, and documentation.

## Changes Made

### 1. File Structure
Reorganized the theme system into a modular structure:

```
src/theme/
├── components/           # Theme-related React components
│   └── ThemeProvider.tsx  # Theme provider component
├── context/               # Theme context
│   └── ThemeContext.ts
├── hooks/                 # Theme-related hooks
│   └── useTheme.ts
├── managers/             # Theme management logic
│   └── ThemeManager.ts
├── themes/               # Theme definitions
│   ├── base.ts           # Base theme configuration
│   ├── dark.ts           # Dark theme
│   ├── index.ts          # Theme exports
│   └── light.ts          # Light theme
├── types/                # TypeScript type definitions
│   └── index.ts
├── README.md             # Module documentation
└── index.ts              # Public API
```

### 2. Type Safety Improvements
- Added comprehensive TypeScript types for all theme-related interfaces
- Removed `any` types in favor of proper type definitions
- Added type guards for theme validation
- Improved type documentation with JSDoc comments

### 3. Theme Management
- Implemented a singleton `ThemeManager` class to handle theme state
- Added support for system preference detection
- Improved theme persistence using localStorage
- Added proper cleanup for event listeners

### 4. Performance Optimizations
- Memoized theme creation to prevent unnecessary re-renders
- Optimized theme updates using a pub/sub pattern
- Lazy-loaded theme variants

### 5. Documentation
- Added comprehensive JSDoc comments
- Created a detailed README.md for the theme module
- Documented theme structure and usage patterns
- Added examples for common use cases

## Migration Guide

### For Component Developers

1. **Importing the Theme**
   ```typescript
   import { useTheme } from '../../theme';
   
   function MyComponent() {
     const { theme, isDark, toggleTheme } = useTheme();
     // ...
   }
   ```

2. **Using Theme Values**
   ```typescript
   // In styled components
   const StyledDiv = styled('div')(({ theme }) => ({
     backgroundColor: theme.palette.background.default,
     color: theme.palette.text.primary,
   }));
   ```

3. **Theme Switching**
   ```typescript
   const { toggleTheme, setTheme } = useTheme();
   
   // Toggle between light/dark
   <button onClick={toggleTheme}>Toggle Theme</button>
   
   // Set specific theme
   <button onClick={() => setTheme('dark')}>Dark Theme</button>
   <button onClick={() => setTheme('light')}>Light Theme</button>
   <button onClick={() => setTheme('system')}>System Default</button>
   ```

## Testing

### Unit Tests
Added unit tests for theme-related functionality:
- Theme switching
- System preference detection
- Theme persistence
- Type validation

### Manual Testing
Verify the following:
1. Theme toggles correctly between light and dark modes
2. System preference is detected and applied
3. Theme persists across page reloads
4. All components respect the current theme
5. No console errors related to theme switching

## Future Improvements

1. **Theme Customization**
   - Add support for custom themes
   - Implement theme editor UI
   - Allow saving custom themes

2. **Performance**
   - Implement code splitting for themes
   - Add theme loading states
   - Optimize theme updates

3. **Accessibility**
   - Add high contrast theme option
   - Improve color contrast ratios
   - Add theme-aware focus styles

## Dependencies
- Material-UI v5
- TypeScript 4.9+
- React 18+

## Related PRs
- #123: Initial theme system implementation
- #145: Theme type safety improvements
- #167: Theme system documentation

================
File: docs/cleanup/TYPES.md
================
# Types Cleanup

## Overview
This document tracks the cleanup and optimization of type definitions in the codebase.

## Current Status
- **Status**: In Progress
- **Last Updated**: 2025-05-13
- **Target Directories**: 
  - `/src/types`
  - `/src/components/*/types.ts`
  - Component prop types
- **Blocked By**: None
- **Progress**: 85% complete

## Type Categories

## Type Audit Findings

### 1. Core Types
- [x] **User-related types**
  - [x] `User` interface (in `types/index.ts`)
  - [x] `UserProfile` (consolidated in `types/user.ts`)
  - [x] `AuthState` (in `types/auth.ts`)
  - [x] `UserPreferences` (in `types/user.ts`)
  - [x] `Creator` interface (in `types/index.ts`)
  - [x] `SubscriptionLevel` (in `types/index.ts`)
  - [x] `UserStats` (in `types/user.ts`)
  - [x] `SocialLinks` (in `types/user.ts`)
  - [x] `UserRole` (in `types/user.ts`)
  - [x] `UserSearchResult` (in `types/user.ts`)
  - [x] `FeaturedProfile` (in `types/user.ts`)
  - [x] `ProfileInput` (in `types/user.ts`)
  - [x] `UserSettingsUpdate` (in `types/user.ts`)

- [x] **Content Types**
  - [x] `Content` interface (in `types/index.ts`)
  - [x] `Comment` (consolidated in `types/index.ts` and `components/content/components/types.ts`)
  - [x] `ContentCardProps` (in `components/content/types.ts` and `components/content/components/types.ts`)
  - [x] `Post` (in `components/content/PostCard.tsx`)
  - [x] `Category` (in `components/content/ContentCategories.tsx`)
  - [x] `ContentCategories` props (in `components/content/ContentCategories.tsx`)

- [x] **API Response Types**
  - [x] `ApiResponse<T>` (in `types/user.ts`)
  - [x] `PaginatedResult<T>` (in `types/user.ts`)
  - [x] `ErrorResponse` (part of `ApiResponse` in `types/user.ts`)

- [x] **State Management**
  - [x] `AuthState` (in `types/auth.ts`)
  - [x] `UserStats` (in `types/user.ts`)
  - [x] `SocialLinks` (in `types/user.ts`)
  - [x] `LoadingState` (in `contexts/LoadingStateContext.tsx`)
  - [ ] `AppState` (not needed - using React Context)
  - [ ] `UIState` (not needed - using component state)

### 2. Component Props
- [x] **Shared Props**
  - [x] `ButtonProps` (in `components/ui/Button.tsx`)
  - [x] `CardProps` (in `components/ui/Card.tsx`)
  - [x] `IconButtonProps` (in `components/ui/IconButton.tsx`)
  - [ ] `BaseProps` (not implemented - consider if needed)
  - [ ] `ThemeableProps` (not implemented - using MUI theming)
  - [ ] `AccessibilityProps` (partially implemented in components)

- [x] **Form Components**
  - [x] `ProfileFormData` (in `components/profile/types.ts`)
  - [x] `FormData` (in `types/auth.ts`)
  - [x] `FormErrors` (in `types/auth.ts`)
  - [x] `LoginFormProps` (in `components/auth/LoginForm.tsx`)
  - [x] `ProfileFormState` (in `components/profile/form/ProfileFormState.ts`)
  - [ ] `FormFieldProps` (partially implemented in form components)
  - [x] `ButtonProps` (in `components/ui/Button.tsx`)
  - [ ] `InputProps` (partially implemented in form components)

- [x] **Layout Components**
  - [x] `LayoutProps` (in `components/layout/ProfileLayout.tsx`)
  - [x] `ContainerProps` (using MUI Container props)
  - [x] `GridProps` (using MUI Grid props)
  - [x] `ProfileLayoutProps` (in `components/profile/ProfileLayout.tsx`)

- [x] **Content Components**
  - [x] `ContentCardProps` (in `components/content/types.ts` and `components/content/components/types.ts`)
  - [x] `PostCardProps` (in `components/content/PostCard.tsx`)
  - [x] `ContentCategoriesProps` (in `components/content/ContentCategories.tsx`)
  - [x] `ProfileSectionProps` (in `components/content/ProfileSection.tsx`)
  - [x] `SubscriptionPlansProps` (in `components/subscription/SubscriptionPlans.tsx`)

### 3. API & Database Types
- [x] **Request Types**
  - [x] `LoginRequest` (as `FormData` in `types/auth.ts`)
  - [x] `ProfileInput` (in `types/user.ts`)
  - [x] `UserSettingsUpdate` (in `types/user.ts`)
  - [x] `PartialProfileUpdate` (in `types/user.ts`)
  - [x] `FeaturedProfileConfig` (in `types/user.ts`)
  - [ ] `CreatePostRequest` (not implemented - needed for future features)
  - [ ] `UpdatePostRequest` (not implemented - needed for future features)

- [x] **Query Parameters**
  - [x] `PaginationParams` (part of `PaginatedResult` in `types/user.ts`)
  - [ ] `SortingParams` (not implemented - needed for future features)
  - [ ] `FilterParams` (not implemented - needed for future features)

- [x] **Error Types**
  - [x] `ApiError` (part of `ApiResponse` in `types/user.ts`)
  - [x] `FormErrors` (in `types/auth.ts`)
  - [x] `ProfileErrors` (in `components/profile/types.ts`)
  - [ ] `NetworkError` (handled by error boundaries and API client)

- [x] **Database Types** (in `types/database.ts`)
  - [x] `IUser` (Mongoose model)
  - [x] `IUserProfile` (Mongoose model)
  - [x] `IUserStats` (Mongoose model)
  - [x] `ISubscription` (Mongoose model)
  - [x] `ISocialLinks` (Mongoose model)
  - [x] `IUserRelationship` (Mongoose model)
  - [x] `IUserPreferences` (Mongoose model)
  - [x] `ISubscriptionTier` (Mongoose model)
  - [x] `IDailyStat` (Mongoose model)
  - [x] `IMonthlyStat` (Mongoose model)

## Type Cleanup Plan

### 1. Type Consolidation - COMPLETED
- [x] **Resolved Duplicates**
  - [x] Consolidated `UserProfile` types into `types/user.ts`
  - [x] Standardized `SocialLinks` interface in `types/user.ts`
  - [x] Consolidated `Comment` types between `types/index.ts` and `components/content/components/types.ts`
  - [x] Standardized form error types across the application

### 2. Naming Conventions - IN PROGRESS
- [x] **Standardized Naming**
  - [x] Using `I` prefix for database interfaces (e.g., `IUser`, `IUserProfile`)
  - [x] Using regular interfaces for application types (e.g., `UserProfile`, `Content`)
  - [x] Standardized file naming:
    - `types/*.ts` for core type definitions
    - `components/*/types.ts` for component-specific types
- [x] **Type Organization**
  - [x] Grouped related types by domain (user, content, auth, etc.)
  - [x] Created dedicated type files for database models

### 3. Type Definitions Enhancement - COMPLETED
- [x] **Added Missing Types**
  - [x] Added comprehensive user and profile types
  - [x] Added content and post-related types
  - [x] Added API response types with proper generics
  - [x] Added database model interfaces
  - [x] Added form and validation types

- [x] **Type Safety**
  - [x] Replaced most `any` types with proper types
  - [x] Added proper generics for reusable types (e.g., `ApiResponse<T>`, `PaginatedResult<T>`)
  - [x] Ensured type safety in function parameters and return types
  - [x] Added type guards where needed

### 4. Type Organization - COMPLETED
- [x] **File Structure**
  ```
  src/
    types/
      index.ts         # Main type exports
      user.ts          # User-related types
      auth.ts          # Authentication types
      database.ts      # Database model interfaces
      
    components/     
      component-name/
        types.ts      # Component-specific types
        
    services/
      api/
        types/       # API-specific types
  ```
  
- [x] **Barrel Exports**
  - [x] Centralized type exports in `types/index.ts`
  - [x] Organized types by feature and domain
  - [x] Maintained consistent import patterns

- [ ] **Documentation**
  - [ ] Add JSDoc to all types
  - [ ] Document type relationships
  - [ ] Add usage examples for complex types
  - [ ] Document type guards and utility types

### 5. Documentation & Best Practices - IN PROGRESS
- [x] **JSDoc Comments**
  - [x] Added JSDoc comments to all major types
  - [x] Documented type properties and methods
  - [x] Added examples for complex types
  - [ ] Need to complete documentation for all utility types

```typescript
/**
 * Represents a user in the system
 * @interface User
 * @property {string} id - Unique user identifier
 * @property {string} username - User's display name
 * @property {UserRole} role - User's access level
 * @property {string} [bio] - Optional user biography
 * @property {string} [avatarUrl] - URL to user's avatar image
 * @property {string} [coverUrl] - URL to user's cover image
 * @property {boolean} isCreator - Whether the user is a content creator
 */
interface User {
  id: string;
  username: string;
  name: string;
  email: string;
  bio?: string;
  avatarUrl?: string;
  coverUrl?: string;
  isCreator: boolean;
}
```

- [x] **Type Documentation**
  - [x] Documented all major type properties
  - [x] Added examples for complex types
  - [x] Documented type constraints and limitations
  - [x] Added deprecation notices for legacy types

### 6. Type Safety & Validation - PARTIALLY COMPLETE
- [x] **Runtime Validation**
  - [x] Implemented type guards for critical types
  - [x] Added basic schema validation for API responses
  - [x] Added input validation for forms
  - [ ] Consider adding Zod for more robust validation

- [ ] **Type Testing**
  - [ ] Add type tests using `tsd` or similar
  - [ ] Test type inference in critical paths
  - [ ] Verify type compatibility across modules

## Next Steps

1. **Complete Documentation**
   - Finish JSDoc comments for remaining types
   - Add more usage examples
   - Document type relationships

2. **Enhance Type Safety**
   - Add more precise types for form handling
   - Implement stricter type checking for API responses
   - Add runtime validation for critical data

3. **Performance Optimization**
   - Use `type` instead of `interface` where appropriate
   - Consider using `Omit`, `Pick`, and other utility types
   - Evaluate use of `as const` for literal types

4. **Future Improvements**
   - Add TypeScript strict mode
   - Implement discriminated unions for better type narrowing
   - Add more comprehensive error types

## Type Naming Conventions

### Naming Rules
- **PascalCase** for:
  - Interfaces
  - Type aliases
  - Enums
  - Generic type parameters

- **camelCase** for:
  - Type properties
  - Function parameters
  - Local type variables

### Type Definition Examples
```typescript
// Interface
interface UserProfile {
  id: string;
  displayName: string;
  email: string;
}

// Type alias
type UserRole = 'admin' | 'user' | 'guest';

// Generic type
interface ApiResponse<T> {
  data: T;
  status: number;
  error?: string;
}
```

### File Naming
- Use `.types.ts` suffix for type-only files
- Group related types in feature-based files
- Keep type files co-located with their components when specific to a component
- Prefix with `I` for interfaces (optional)
- Use `T` prefix for generic types
- Suffix with `Props` for component props
- Suffix with `Type` for union/intersection types

## Common Issues to Address
- Inconsistent type naming
- Missing type definitions
- Overuse of `any` type
- Duplicate type definitions
- Complex nested types that could be simplified

## Action Items

### High Priority
1. Audit and consolidate user-related types
2. Remove any `any` types
3. Document all types with JSDoc

### Medium Priority
1. Organize types into logical groups
2. Set up type-only imports/exports
3. Add type tests

### Low Priority
1. Create type utilities
2. Add runtime type checking
3. Document type patterns

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Audit user-related types

## Notes
- Pay attention to type reusability
- Document type transformations
- Keep an eye on type inference performance
- Consider creating type utilities for common patterns

================
File: docs/cleanup/UTILS.md
================
# Utils Cleanup

## Overview
This document tracks the cleanup and optimization of utility functions in the `/src/utils` directory.

## Current Status
- **Status**: In Progress (Phase 1)
- **Last Updated**: 2025-05-13
- **Target Directory**: `/src/utils`
- **Dependencies**: 
  - ✅ Types Cleanup (Phase 1)
  - ✅ Hooks Cleanup (Phase 1)

## Utils Inventory

### Utility Files
| File | Category | Functions | Dependencies | Status |
|------|----------|------------|--------------|--------|
| `constants.ts` | Configuration | API configuration | - | ✅ Enhanced |
| `format.ts` | Formatting | `formatNumber`, `formatCompactNumber`, `formatRelativeTime` | - | ✅ Enhanced |
| `imageUtils.ts` | Media | `getStaticImageUrl`, `getPlaceholderImages`, `getPlaceholderImage` | - | ✅ Enhanced |
| `logger.ts` | Logging | `Logger` class with multiple log levels | - | ✅ Enhanced |
| `index.ts` | Exports | Barrel file for all utils | - | ✅ Created |

## Audit Checklist

### 1. Code Quality & Organization
- [ ] **Function Implementation**
  - [ ] Remove duplicate functions
  - [ ] Ensure consistent naming (camelCase)
  - [ ] Verify pure functions where possible
  - [ ] Remove unused code
  - [ ] Consolidate similar utilities

- [ ] **File Structure**
  - [ ] Group related utilities in appropriate files
  - [ ] Create index files for exports
  - [ ] Follow consistent file naming
  - [ ] Separate concerns appropriately

### 2. Type Safety & Validation
- [ ] **TypeScript Implementation**
  ```typescript
  // Before
  function formatDate(date) {
    // ...
  }
  
  // After
  function formatDate(date: Date | string | number): string {
    // ...
  }
  ```
  - [ ] Add proper TypeScript types
  - [ ] Remove `any` types
  - [ ] Add input validation
  - [ ] Use proper return types

### 3. Documentation & Best Practices
- [ ] **JSDoc Comments**
  ```typescript
  /**
   * Formats a date into a human-readable string
   * @param {Date|string|number} date - The date to format
   * @param {string} [formatString='MMM d, yyyy'] - Optional format string
   * @returns {string} Formatted date string
   * @example
   * formatDate(new Date()); // 'May 12, 2023'
   * formatDate('2023-05-12', 'yyyy-MM-dd'); // '2023-05-12'
   */
  function formatDate(date: Date | string | number, formatString = 'MMM d, yyyy'): string
  ```
  - [ ] Document all functions
  - [ ] Add examples
  - [ ] Document edge cases
  - [ ] Add deprecation notices

### 4. Testing & Quality
- [ ] **Unit Tests**
  ```typescript
  describe('formatDate', () => {
    it('should format date correctly', () => {
      const date = new Date('2023-05-12');
      expect(formatDate(date)).toBe('May 12, 2023');
    });
  });
  ```
  - [ ] Add test coverage
  - [ ] Test edge cases
  - [ ] Add performance tests for critical functions
  - [ ] Document test cases

## Common Issues to Address

### Code Quality
- Duplicate or similar utility functions
- Inconsistent function signatures
- Lack of input validation
- Poor error handling
- Missing type definitions

### Performance
- Inefficient algorithms
- Unnecessary computations
- Memory leaks
- Lack of caching for expensive operations

### Documentation
- Missing JSDoc comments
- Undocumented parameters and return values
- No examples provided
- Missing edge case documentation

## Best Practices

### Function Design
```typescript
// Good: Pure function with proper types and validation
function formatCurrency(
  amount: number, 
  locale = 'en-US', 
  currency = 'USD'
): string {
  if (typeof amount !== 'number') {
    throw new TypeError('Amount must be a number');
  }
  
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  }).format(amount);
}
```

### Error Handling
```typescript
// Handle errors appropriately
function parseJSON<T>(jsonString: string): T | null {
  try {
    return JSON.parse(jsonString) as T;
  } catch (error) {
    console.error('Failed to parse JSON:', error);
    return null;
  }
}
```

### Performance Optimization
```typescript
// Memoize expensive operations
const memoizedHeavyComputation = memoize((input: string) => {
  // Expensive computation
  return heavyComputation(input);
});

// Debounce frequent operations
const debouncedSearch = debounce((query: string) => {
  searchAPI(query);
}, 300);
```

## Action Items

### High Priority
1. Audit and document all utility functions
2. Add TypeScript types
3. Implement proper error handling
4. Add input validation

### Medium Priority
1. Optimize performance-critical functions
2. Add unit tests
3. Document usage examples
4. Set up code coverage reporting

### Low Priority
1. Add performance benchmarks
2. Create utility documentation
3. Set up automated code quality checks

## Action Items

### High Priority
1. Audit all utility functions
2. Add TypeScript types
3. Document all functions

### Medium Priority
1. Add input validation
2. Create tests
3. Optimize performance

### Low Priority
1. Add benchmarks
2. Create utility templates
3. Document patterns

## Progress Log

### 2025-05-12
- Initial documentation created
- Next: Audit all utility functions

## Version History

### 1.0.0 - 2025-05-12
- Initial version created
- Documented all utility functions
- Added audit checklist
- Identified optimization opportunities

## Notes
- Keep utility functions pure and focused
- Document all parameters and return values
- Add unit tests for all utilities
- Consider creating a utilities documentation site file

================
File: docs/migrations/loading-context-migration.md
================
# Loading Context Migration Guide

This guide will help you migrate from the old loading contexts (`LoadingContext` and `LoadingStateContext`) to the new unified `LoadingContextV2`.

## What's New

- **Unified API**: Single context for all loading state management
- **Better TypeScript Support**: Improved type safety and intellisense
- **More Features**: Built-in support for loading time tracking, error handling, and async operations
- **Backward Compatibility**: Drop-in replacement for existing code

## Migration Steps

### 1. Update Imports

#### Before:
```typescript
import { useLoading } from '../../contexts/LoadingContext';
// or
import { useLoadingState } from '../../contexts/LoadingStateContext';
```

#### After:
```typescript
import { useLoadingContext } from '../../contexts/LoadingContextV2';
// For backward compatibility
import { useLoadingState } from '../../contexts/LoadingContextV2';
```

### 2. Update Provider Setup

#### Before:
```tsx
<LoadingProvider>
  <LoadingStateProvider>
    <App />
  </LoadingStateProvider>
</LoadingProvider>
```

#### After:
```tsx
<LoadingProvider>
  <App />
</LoadingProvider>
```

### 3. Update Hook Usage

#### Simple Loading State

##### Before:
```typescript
const { isLoading, startLoading, stopLoading } = useLoading();
// or
const { loadingState, setLoadingState } = useLoadingState();
```

##### After:
```typescript
const { isLoading, startLoading, stopLoading } = useLoadingContext();
// or (for backward compatibility)
const { loadingState, setLoadingState } = useLoadingState();
```

#### Async Operations

##### Before:
```typescript
const { withLoading } = useLoading();

const fetchData = withLoading(async () => {
  const response = await fetch('/api/data');
  return response.json();
});
```

##### After:
```typescript
const { wrapAsync } = useLoadingContext();

const fetchData = wrapAsync(async () => {
  const response = await fetch('/api/data');
  return response.json();
});
```

### 4. New Features

#### Multiple Loading States
```typescript
const { 
  getLoadingState, 
  startLoading, 
  stopLoading 
} = useLoadingContext();

// Start a specific loading state
startLoading('userProfile');

// Check loading state
const { isLoading } = getLoadingState('userProfile');

// Stop loading with optional error
stopLoading('userProfile', error);
```

#### Loading Time Tracking
```typescript
const { getLoadingTime } = useLoadingContext();

// Get loading time in milliseconds
const loadingTime = getLoadingTime('default');
```

### 5. Deprecations

The following features are deprecated but still available for backward compatibility:

- `useLoading` hook (use `useLoadingContext` instead)
- `useLoadingState` hook (use `useLoadingContext` directly)
- `loadingState` and `setLoadingState` in the context value

## Migration Checklist

- [ ] Update all imports to use the new context
- [ ] Remove any nested `LoadingStateProvider` usages
- [ ] Update component implementations to use the new API
- [ ] Test all loading states and error handling
- [ ] Remove old context files after migration is complete

## Troubleshooting

### Loading states not updating
Make sure you're using the correct loading ID when working with multiple loading states.

### Type errors
Check that you're using the correct types from the new context. The API has been updated to be more type-safe.

### Performance issues
If you notice performance issues, make sure to use the appropriate loading IDs to prevent unnecessary re-renders.

================
File: docs/api.md
================
# API Documentation

## Authentication

### POST /api/auth/signup
Create a new user account.

**Request Body:**
```json
{
  "email": "user@example.com",
  "username": "username",
  "password": "password123"
}
```

**Response:**
```json
{
  "token": "jwt_token",
  "user": {
    "id": "user_id",
    "email": "user@example.com",
    "username": "username"
  }
}
```

### POST /api/auth/login
Authenticate user and get token.

**Request Body:**
```json
{
  "email": "user@example.com",
  "password": "password123"
}
```

**Response:**
```json
{
  "token": "jwt_token",
  "user": {
    "id": "user_id",
    "email": "user@example.com",
    "username": "username",
    "isCreator": false
  }
}
```

## Content

### POST /api/content/upload
Upload new content (requires authentication).

**Request Body (multipart/form-data):**
- title: string
- description: string
- isExclusive: boolean
- mediaType: 'video' | 'image'
- thumbnail: File
- media: File

**Response:**
```json
{
  "contentId": "content_id",
  "message": "Content uploaded successfully"
}
```

### GET /api/content/:id
Get content by ID.

**Response:**
```json
{
  "id": "content_id",
  "title": "Content Title",
  "description": "Content Description",
  "mediaType": "video",
  "mediaUrl": "https://...",
  "thumbnailUrl": "https://...",
  "isExclusive": false,
  "likes": 0,
  "views": 0,
  "creator": {
    "username": "creator",
    "name": "Creator Name",
    "avatarUrl": "https://..."
  }
}
```

## Subscriptions

### POST /api/subscriptions/create
Create a new subscription (requires authentication).

**Request Body:**
```json
{
  "planId": "plan_id"
}
```

**Response:**
```json
{
  "sessionUrl": "https://checkout.stripe.com/..."
}
```

### GET /api/subscriptions/status/:creatorId
Check subscription status for a creator (requires authentication).

**Response:**
```json
{
  "isSubscribed": true,
  "subscription": {
    "id": "subscription_id",
    "status": "active",
    "createdAt": "2024-01-01T00:00:00Z"
  }
}
```

## Categories

### GET /api/categories
Get all content categories.

**Response:**
```json
[
  {
    "id": "category_id",
    "name": "Category Name",
    "description": "Category Description",
    "imageUrl": "https://...",
    "contentCount": 10
  }
]
```

### GET /api/categories/:id/content
Get content for a specific category.

**Response:**
```json
{
  "category": {
    "id": "category_id",
    "name": "Category Name"
  },
  "contents": [
    {
      "id": "content_id",
      "title": "Content Title",
      "thumbnailUrl": "https://...",
      "creator": {
        "username": "creator",
        "name": "Creator Name"
      }
    }
  ]
}
```

## Error Responses

All endpoints may return the following error responses:

### 400 Bad Request
```json
{
  "message": "Validation error message"
}
```

### 401 Unauthorized
```json
{
  "message": "Authentication required"
}
```

### 403 Forbidden
```json
{
  "message": "Access denied"
}
```

### 404 Not Found
```json
{
  "message": "Resource not found"
}
```

### 500 Internal Server Error
```json
{
  "message": "Internal server error"
}
```

================
File: docs/authentication.md
================
# Authentication System

## Overview
Sushflix implements a robust authentication system that supports both login and signup functionality. The system is built using React Context for state management and integrates with the backend API for user authentication.

## Components

### LoginModal
The `LoginModal` component provides a user-friendly interface for both login and signup operations. It supports two authentication methods:

1. **Email/Username + Password**
2. **Phone Number + OTP**

#### Props
```typescript
interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
}
```

#### Features
- Form validation for email/username and password
- Phone number validation
- OTP support for phone authentication
- Error handling and display
- Automatic redirect to `/explore` after successful authentication

### AuthContext
The `AuthContext` provides authentication state management and related functions throughout the application.

#### Context Type
```typescript
interface AuthContextType {
  user: UserProfile | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<UserProfile>;
  logout: () => void;
  error: string | null;
}
```

## Authentication Flow

### Login Flow
1. User enters email/username and password
2. Form validation is performed
3. API call to `/auth/login` is made
4. On success:
   - User data is stored in localStorage
   - Auth state is updated
   - User is redirected to `/explore`
5. On error:
   - Error message is displayed
   - Form remains open for retry

### Signup Flow
1. User enters email/username and password
2. Form validation is performed
3. API call to `/auth/signup` is made
4. On success:
   - User data is stored in localStorage
   - Auth state is updated
   - User is redirected to `/explore`
5. On error:
   - Error message is displayed
   - Form remains open for retry

## Error Handling
The system implements comprehensive error handling at multiple levels:

1. **Form Level Validation**
   - Email format validation
   - Password strength validation
   - Phone number format validation

2. **API Error Handling**
   - Network errors
   - Authentication failures
   - Server errors

3. **User Feedback**
   - Clear error messages
   - Loading states
   - Success notifications

## Security Features

### Token Management
- JWT tokens are stored in localStorage
- Tokens are automatically included in API requests
- Token expiration handling

### Input Validation
- All user inputs are validated before submission
- Password strength requirements
- Email format validation
- Phone number format validation

### Error Logging
- All authentication actions are logged
- API responses are logged
- Error messages are logged for debugging

## Usage Examples

### Using AuthContext
```typescript
const { user, isAuthenticated, login, logout } = useAuth();

// Check authentication status
if (!isAuthenticated) {
  // Show login modal
}

// Handle login
const handleLogin = async () => {
  try {
    await login(email, password);
    // User will be redirected to /explore
  } catch (error) {
    // Handle login error
  }
};
```

================
File: docs/edit profile roadmap
================
Steps to Implement Edit Profile Modal
Create EditProfileModal Component
New file: EditProfileModal.tsx
Use Material-UI's Modal or your custom Modal component
Include form fields for editable profile data
Add image upload for profile picture
Set Up State Management
Create form state for editable fields
Add loading states for API calls
Add error handling state
Integrate with ProfileService
Use updateProfile for text fields
Use uploadProfilePicture for image uploads
Handle success/error responses
Add UI Components
Form fields for:
Display name
Bio
Other editable fields
Profile picture upload with preview
Save/Cancel buttons
Connect to ProfilePage
Add state to control modal visibility
Pass user data to modal
Add success callback to update UI
Add Validation
Field-level validation
Form submission validation
Error display
Testing
Test all form fields
Test image upload
Test error cases
Verify UI updates
Questions Before Starting:
Should the modal be full-screen or a smaller dialog? => smaller but just enough to have all components in it, not too small but not big eiter
Which fields should be editable? => 
on top will be profilepicture component which will have a upload button, name, bio can be editable
Any specific validation rules? profile picture validation is already implemented, no other validations to any field, max character count can be 200
Should we show a preview of the new profile picture before saving? yes when we click on the upload icon and select the image, the image will be shown and when save button in the edit modal will be clicked, the api calls will be made respectively for profile picture and profile update
Any specific styling requirements? should be similar to how other social media platforms have it, clean simple but easy to modify with loose coupling

================
File: docs/featured-profiles.json
================
{
    "featuredProfiles": [
      {
        "userId": "1",
        "username": "@miishi.khanna.official",
        "isActive": true,
        "displayOrder": 1,
        "profile": {
          "userId": "u1",
          "username": "Mishika Khanna",
          "displayName": "Mishika Khanna",
          "profilePicture": "https://images.unsplash.com/photo-1570295999919-56ceb5ecca61?w=300",
          "bio": "Co-Founder of SushFlix",
          "socialLinks": {
            "instagram": "https://instagram.com/sushflix",
            "twitter": "https://twitter.com/sushflix",
            "website": "https://sushflix.com"
          }
        }
      },
      {
        "userId": "u2",
        "username": "sushmaster",
        "isActive": true,
        "displayOrder": 2,
        "profile": {
          "userId": "user2",
          "username": "sushmaster",
          "displayName": "Chef Sushi Master",
          "profilePicture": "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=300",
          "bio": "Professional sushi chef with 15 years of experience",
          "socialLinks": {
            "instagram": "https://instagram.com/sushmaster",
            "twitter": "https://twitter.com/sushmaster",
            "website": "https://sushmaster.com"
          }
        }
      },
      {
        "userId": "user3",
        "username": "sushilover",
        "isActive": true,
        "displayOrder": 3,
        "profile": {
          "userId": "user3",
          "username": "sushilover",
          "displayName": "Sushi Enthusiast",
          "profilePicture": "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=300",
          "bio": "Sushi lover and food blogger sharing amazing sushi experiences",
          "socialLinks": {
            "instagram": "https://instagram.com/sushilover",
            "twitter": "https://twitter.com/sushilover",
            "website": "https://sushilover.com"
          }
        }
      }
    ]
  }

================
File: docs/homepage_components.json
================
{
  "page_structure": {
    "layout": "flex flex-col min-h-screen bg-white",
    "main_container": "flex-grow container mx-auto px-6 md:px-12 py-12",
    "grid_layout": "grid grid-cols-1 md:grid-cols-2 gap-12 items-center"
  },
  
  "components": {
    "left_column": {
      "community_icons": {
        "image": "/images/community_icons.png",
        "text": "TRUSTED BY A DIVERSE COMMUNITY OF CREATORS",
        "layout": "flex items-center mb-4",
        "text_class": "text-gray-700 uppercase text-xs font-semibold tracking-widest"
      },
      "heading": {
        "text": "Get paid to do what you love.",
        "styles": "text-5xl md:text-6xl font-bold text-gray-800 mb-6"
      },
      "subheading": {
        "text": "Share your content on your own terms, and connect with your fans like never before.",
        "styles": "text-gray-600 text-lg mb-8"
      },
      "cta_buttons": {
        "common_styles": "bg-red-600 text-white px-6 py-3 rounded-full font-medium hover:bg-red-700",
        "buttons": [
          { "text": "Become a Creator", "link": "/signup?type=creator" },
          { "text": "Sign up as a Fan", "link": "/signup?type=fan" }
        ]
      }
    },
    
    "right_column": {
      "profile_card": {
        "container": {
          "background": "white",
          "border_radius": "rounded-2xl",
          "shadow": "shadow-lg",
          "padding": "p-6",
          "z_index": "z-10"
        },
        "profile_image": {
          "size": "w-16 h-16",
          "shape": "rounded-full",
          "container": "overflow-hidden",
          "image": {
            "src": "state.profile?.profilePicture || "/static/images/profile.jpeg"",
            "styles": "w-full h-full object-cover"
          }
        },
        "profile_info": {
          "username": "state.featuredProfiles[0]?.username",
          "bio": "state.featuredProfiles[0]?.bio",
          "styles": {
            "username": "font-semibold text-lg",
            "bio": "text-gray-600 text-sm"
          }
        },
        "stats_grid": {
          "layout": "grid grid-cols-3 gap-4 mb-6",
          "text_size": "text-sm sm:text-base",
          "centering": "text-center",
          "stats": ["posts", "followers", "subscribers"]
        },
        "action_buttons": {
          "common_styles": "bg-red-600 text-white px-4 py-2 rounded-full font-medium hover:bg-red-700",
          "layout": "flex flex-col sm:flex-row",
          "spacing": "space-y-2 sm:space-y-0 sm:space-x-4",
          "buttons": [
            { "text": "Watch Video" },
            { "text": "Message" },
            { "text": "Send Tip" }
          ]
        }
      }
    }
  },
  
  "state_management": {
    "interfaces": {
      "HomePageState": {
        "properties": [
          "profile: UserProfile | null",
          "featuredProfiles: FeaturedProfile[]",
          "isLoading: boolean",
          "error: string | null",
          "retryCount: number",
          "maxRetries: number"
        ]
      }
    }
  },
  
  "api_endpoints": {
    "profile": {
      "method": "GET",
      "path": "/api/profile"
    },
    "featured_profiles": {
      "method": "GET",
      "path": "/api/profiles/featured"
    }
  },
  
  "color_scheme": {
    "primary": "red",
    "text_colors": {
      "primary": "text-gray-800",
      "secondary": "text-gray-600",
      "tertiary": "text-gray-700"
    },
    "background": "white",
    "button": {
      "base": "bg-red-600",
      "hover": "hover:bg-red-700"
    }
  },
  
  "responsive_design": {
    "breakpoints": {
      "mobile": "grid-cols-1",
      "desktop": "grid-cols-2",
      "padding": {
        "mobile": "px-6",
        "desktop": "md:px-12"
      },
      "button_spacing": {
        "mobile": "space-y-2",
        "desktop": "sm:space-y-0 sm:space-x-4"
      }
    }
  },
  
  "ui_components": {
    "error_handling": {
      "error_boundary": true,
      "retry_functionality": true,
      "loading_states": true
    },
    "core_components": [
      "ErrorBoundary",
      "Loading",
      "Link"
    ],
    "button_styles": {
      "primary": "bg-red-600 text-white rounded-full font-medium hover:bg-red-700"
    }
  }
}

================
File: docs/implementation_plan.md
================
# Sushflix Implementation Plan

## Overview
This document outlines the planned improvements for the Sushflix application, focusing on core infrastructure and component enhancements.

## Phase 1: Core Infrastructure Improvements (Completed)

### 1. Error Handling System (Completed)
- ✅ Create a centralized error boundary component
- ✅ Implement consistent error states across all components
- ✅ Add proper error logging
- ✅ Create reusable error components
- ✅ Wrap all major components with ErrorBoundary
- ✅ Implement retry functionality for failed operations

### 2. Loading States (Completed)
- ✅ Create a reusable loading component
- ✅ Add skeleton loading screens
- ✅ Implement proper loading indicators
- ✅ Create LoadingStateContext for global state management
- ✅ Implement loading states in HomePage and ProfilePage
- ✅ Update components to use new loading system
- ✅ Remove old LoadingSpinner usage
- ✅ Add loading states for all user interactions

### 3. Type System (Completed)
- ✅ Consolidated type definitions in user.ts
- ✅ Proper type definitions for UserProfile, Post, and UserStats
- ✅ Removed unused profile types file
- ✅ Fixed type conflicts between user and profile types
- ✅ Added proper type safety for API responses

## Phase 2: Component Improvements (In Progress)

### 1. Theme System (Completed)
- ✅ Create theme provider
- ✅ Implement theme context
- ✅ Add theme switching functionality
- ✅ Implement dark theme
- ✅ Add theme customization options
- ✅ Document theme variables

### 2. Interactive Features (Next)
- Implement post creation interface
- Add comment section
- Implement direct messaging
- Add notifications
- Implement search functionality
- Add profile editing interface

### 3. Settings Page
- Create settings page with LoadingStateContext
- Implement error boundaries
- Add loading states for settings updates
- Implement theme settings
- Add account settings

## Phase 3: Performance Optimizations

### 1. Code Splitting
- Implement route-based code splitting
- Add lazy loading for components
- Optimize bundle size
- Implement dynamic imports

### 2. State Management
- Optimize React state updates
- Implement memoization where needed
- Add performance monitoring
- Implement state persistence

### 3. API Optimization
- Implement request batching
- Optimize API response sizes
- Implement request debouncing

## Phase 4: Testing and Quality Assurance

### 1. Unit Testing
- Add unit tests for loading states
- Add error boundary tests
- Verify UI consistency

### 2. Integration Testing
- Test API integrations
- Verify state management
- Test error handling

### 3. Performance Testing
- Load testing
- Stress testing
- Performance monitoring
- Browser compatibility testing

## Phase 5: Documentation

### 1. Technical Documentation
- Document all components
- Document state management
- Document error handling

### 2. User Documentation
- Create user guide
- Add API documentation
- Document deployment process
- Create troubleshooting guide

### HomePage Improvements
1. API Integration
   - Move API endpoints to config
   - Implement proper error boundaries
   - Add loading states
   - Add retry logic

2. UI/UX Enhancements
   - Add skeleton loading for profile card
   - Implement proper error states
   - Add success/error notifications
   - Improve responsive design

### ProfilePage Improvements
1. Data Management
   - Clean up commented code
   - Improve follow status integration
   - Add proper error boundaries
   - Implement proper loading states

2. UI/UX Enhancements
   - Add success/error notifications
   - Improve loading states
   - Add proper error boundaries
   - Implement proper form validation

### SettingsPage Improvements
1. Feature Enhancements
   - Add form validation
   - Add loading states for theme toggle
   - Add success/error notifications
   - Add more settings options

2. UI/UX Improvements
   - Standardize styling approach
   - Add proper error boundaries
   - Implement proper loading states
   - Add success/error notifications

## Phase 3: Consistency Improvements

### 1. Styling Consistency
- Standardize between Tailwind and Material-UI
- Create a design system
- Document component styles
- Create reusable UI components

### 2. TypeScript Types
- Add proper TypeScript types
- Create shared interfaces
- Document type definitions
- Implement proper type checking

### 3. Accessibility
- Add proper ARIA labels
- Implement keyboard navigation
- Add screen reader support
- Document accessibility features

## Phase 4: Testing and Documentation

### 1. Testing
- Add unit tests for components
- Add integration tests
- Add E2E tests
- Document test coverage

### 2. Documentation
- Document component usage
- Document API endpoints
- Document styling guidelines
- Document error handling

## Implementation Timeline

### Week 1 (In Progress)
- ✅ Set up core infrastructure
- ✅ Implement error handling (partially)
- ✅ Create loading components
- ❌ Standardize theme system

### Next Steps (Priority Order)
1. **Update Loading Implementation Across Components**
   - Update ProfilePage to use new loading system
   - Update SettingsPage to use new loading system
   - Remove LoadingSpinner usage
   - Update API calls to use LoadingStateContext

2. **Complete Error Handling System**
   - Wrap ProfilePage with ErrorBoundary
   - Wrap SettingsPage with ErrorBoundary
   - Implement proper error boundaries in API calls
   - Add error state management

3. **Implement Caching Strategy**
   - Reimplement cache service
   - Add proper caching for profile data
   - Implement cache invalidation strategy

4. **Theme System Implementation**
   - Standardize theme implementation
   - Create a consistent theme provider
   - Ensure consistent styling across components
   - Document theme variables

### Week 2
- Improve HomePage
- Enhance ProfilePage
- Update SettingsPage
- Add success/error notifications

### Week 3
- Implement consistency improvements
- Add TypeScript types
- Improve accessibility
- Add documentation

### Week 4
- Add testing
- Finalize documentation
- Review and refine
- Deploy changes

## Dependencies
- React Query for data fetching
- React Testing Library for testing
- Jest for unit tests
- Cypress for E2E testing
- Storybook for component documentation

## Success Criteria
- All components have proper error handling
- Consistent loading states across application
- Standardized theme implementation
- Proper TypeScript types
- Improved accessibility
- Comprehensive documentation
- Complete test coverage

## Risk Management
- Create backup plan for styling inconsistencies
- Document fallback strategies
- Plan for API changes
- Prepare for browser compatibility issues

## Monitoring and Maintenance
- Set up error tracking
- Implement performance monitoring
- Create maintenance schedule
- Document update procedures

================
File: docs/layout_implementation.md
================
# Sushflix Implementation Plan

## Overview
This document outlines the planned improvements for the Sushflix application, focusing on core infrastructure and component enhancements.

## Phase 1: Core Infrastructure Improvements (Completed)

### 1. Error Handling System (Completed)
- ✅ Create a centralized error boundary component
- ✅ Implement consistent error states across all components
- ✅ Add proper error logging
- ✅ Create reusable error components
- ✅ Wrap all major components with ErrorBoundary
- ✅ Implement retry functionality for failed operations

### 2. Loading States (Completed)
- ✅ Create a reusable loading component
- ✅ Add skeleton loading screens
- ✅ Implement proper loading indicators
- ✅ Create LoadingStateContext for global state management
- ✅ Implement loading states in HomePage and ProfilePage
- ✅ Update components to use new loading system
- ✅ Remove old LoadingSpinner usage
- ✅ Add loading states for all user interactions
- ✅ Implement React Query integration for loading states
- ✅ Add retry functionality for failed API calls
- ✅ Improve error handling with user-friendly messages
- ✅ Add proper loading states for profile data fetching

### 3. Type System (Completed)
- ✅ Consolidated type definitions in user.ts
- ✅ Proper type definitions for UserProfile, Post, and UserStats
- ✅ Removed unused profile types file
- ✅ Fixed type conflicts between user and profile types
- ✅ Added proper type safety for API responses

## Phase 2: Component Improvements (In Progress)

### 1. Theme System (Completed)
- ✅ Create theme provider
- ✅ Implement theme context
- ✅ Add theme switching functionality
- ✅ Implement dark theme

### 2. Interactive Features (In Progress)
- ✅ Implement post creation
- ✅ Add comment functionality
- ✅ Implement sharing feature
- ✅ Add bookmarking system
- ✅ Improve follow/unfollow system
- ✅ Add proper error handling for interactions

## Phase 3: Advanced Features (Planned)

### 1. Caching Strategy
- Implement React Query caching
- Add cache invalidation strategy
- Implement stale-while-revalidate pattern

### 2. Search Functionality
- Implement search bar component
- Add user search
- Add post search
- Implement search filters

### 3. Settings Page
- Create settings layout
- Add profile settings
- Add theme settings
- Add notification settings
- Add privacy settings

### 4. Performance Optimizations
- Implement code splitting
- Add lazy loading for components
- Optimize image loading
- Implement proper error boundaries
- ✅ Add theme customization options
- ✅ Document theme variables

### 2. Interactive Features (Next)
- Implement post creation interface
- Add comment section
- Implement direct messaging
- Add notifications
- Implement search functionality
- Add profile editing interface

### 3. Settings Page
- Create settings page with LoadingStateContext
- Implement error boundaries
- Add loading states for settings updates
- Implement theme settings
- Add account settings

## Phase 3: Performance Optimizations

### 1. Code Splitting
- Implement route-based code splitting
- Add lazy loading for components
- Optimize bundle size
- Implement dynamic imports

### 2. State Management
- Optimize React state updates
- Implement memoization where needed
- Add performance monitoring
- Implement state persistence

### 3. API Optimization
- Implement request batching
- Optimize API response sizes
- Implement request debouncing

## Phase 4: Testing and Quality Assurance

### 1. Unit Testing
- Add unit tests for loading states
- Add error boundary tests
- Verify UI consistency

### 2. Integration Testing
- Test API integrations
- Verify state management
- Test error handling

### 3. Performance Testing
- Load testing
- Stress testing
- Performance monitoring
- Browser compatibility testing

## Phase 5: Documentation

### 1. Technical Documentation
- Document all components
- Document state management
- Document error handling

### 2. User Documentation
- Create user guide
- Add API documentation
- Document deployment process
- Create troubleshooting guide

### HomePage Improvements
1. API Integration
   - Move API endpoints to config
   - Implement proper error boundaries
   - Add loading states
   - Add retry logic

2. UI/UX Enhancements
   - Add skeleton loading for profile card
   - Implement proper error states
   - Add success/error notifications
   - Improve responsive design

### ProfilePage Improvements
1. Data Management
   - Clean up commented code
   - Improve follow status integration
   - Add proper error boundaries
   - Implement proper loading states

2. UI/UX Enhancements
   - Add success/error notifications
   - Improve loading states
   - Add proper error boundaries
   - Implement proper form validation

### SettingsPage Improvements
1. Feature Enhancements
   - Add form validation
   - Add loading states for theme toggle
   - Add success/error notifications
   - Add more settings options

2. UI/UX Improvements
   - Standardize styling approach
   - Add proper error boundaries
   - Implement proper loading states
   - Add success/error notifications

## Phase 3: Consistency Improvements

### 1. Styling Consistency
- Standardize between Tailwind and Material-UI
- Create a design system
- Document component styles
- Create reusable UI components

### 2. TypeScript Types
- Add proper TypeScript types
- Create shared interfaces
- Document type definitions
- Implement proper type checking

### 3. Accessibility
- Add proper ARIA labels
- Implement keyboard navigation
- Add screen reader support
- Document accessibility features

## Phase 4: Testing and Documentation

### 1. Testing
- Add unit tests for components
- Add integration tests
- Add E2E tests
- Document test coverage

### 2. Documentation
- Document component usage
- Document API endpoints
- Document styling guidelines
- Document error handling

## Implementation Timeline

### Week 1 (In Progress)
- ✅ Set up core infrastructure
- ✅ Implement error handling (partially)
- ✅ Create loading components
- ❌ Standardize theme system

### Next Steps (Priority Order)
1. **Update Loading Implementation Across Components**
   - Update ProfilePage to use new loading system
   - Update SettingsPage to use new loading system
   - Remove LoadingSpinner usage
   - Update API calls to use LoadingStateContext

2. **Complete Error Handling System**
   - Wrap ProfilePage with ErrorBoundary
   - Wrap SettingsPage with ErrorBoundary
   - Implement proper error boundaries in API calls
   - Add error state management

3. **Implement Caching Strategy**
   - Reimplement cache service
   - Add proper caching for profile data
   - Implement cache invalidation strategy

4. **Theme System Implementation**
   - Standardize theme implementation
   - Create a consistent theme provider
   - Ensure consistent styling across components
   - Document theme variables

### Week 2
- Improve HomePage
- Enhance ProfilePage
- Update SettingsPage
- Add success/error notifications

### Week 3
- Implement consistency improvements
- Add TypeScript types
- Improve accessibility
- Add documentation

### Week 4
- Add testing
- Finalize documentation
- Review and refine
- Deploy changes

## Dependencies
- React Query for data fetching
- React Testing Library for testing
- Jest for unit tests
- Cypress for E2E testing
- Storybook for component documentation

## Success Criteria
- All components have proper error handling
- Consistent loading states across application
- Standardized theme implementation
- Proper TypeScript types
- Improved accessibility
- Comprehensive documentation
- Complete test coverage

## Risk Management
- Create backup plan for styling inconsistencies
- Document fallback strategies
- Plan for API changes
- Prepare for browser compatibility issues

## Monitoring and Maintenance
- Set up error tracking
- Implement performance monitoring
- Create maintenance schedule
- Document update procedures

================
File: docs/profile_implementation_plan.md
================
# Profile Functionality Implementation Plan

## Context

### Current State
- We have a basic ProfilePage component that displays user profiles
- Existing Mongoose User model with UserProfile schema
- Basic loading and error handling implemented using React Query
- Theme system and LoadingStateContext already in place
- Using Google Cloud Storage for file uploads
  - Bucket: user-profile-pictures-sushflix
  - Region: us-central1
  - File size limit: 2MB
  - File types allowed: image/*
  - File naming: {username}-{timestamp}.{extension}

### Goals
- Implement complete profile functionality including viewing, editing, and social features
- Create a robust backend API for profile operations
- Ensure proper state management and error handling
- Maintain consistent UI/UX across all profile-related features

## Database Changes Required

### User Collection Schema Updates
```typescript
interface UserDocument {
  _id: ObjectId;
  username: string;
  email: string;
  password: string;
  displayName: string;
  bio: string;
  profilePicture: string;
  socialLinks: {
    website?: string;
    twitter?: string;
    youtube?: string;
  };
  createdAt: Date;
  updatedAt: Date;
  isCreator: boolean;
  
  // Social metrics
  followers: number;
  following: number;
  subscribers: number;
  posts: number;
  
  // Privacy settings
  isPrivate: boolean;
  allowComments: boolean;
  allowDirectMessages: boolean;
}
```

### New Collections
1. `followers` - For tracking follower relationships
2. `posts` - For storing user posts
3. `notifications` - For storing user notifications

## Implementation Steps

### Phase 1: Backend Setup (Completed)

1. **API Endpoints** (Completed)
   - GET /api/users/:username - Get user profile
   - GET /api/posts/:username - Get user posts
   - GET /api/users/:username/stats - Get user statistics
   - POST /api/users/:username/follow - Follow/unfollow user
   - POST /api/posts/:postId/share - Share post
   - POST /api/posts/:postId/bookmark - Bookmark post
   - POST /api/users/:username/profile-picture - Upload profile picture
     - Google Cloud Storage integration
     - File validation
     - Error handling
     - Response format:
       ```typescript
       interface UploadResponse {
         success: boolean;
         imageUrl?: string;
         error?: string;
       }
       ```

2. **Services Implementation** (Completed)
   - Created `profileService.ts` with centralized API endpoints
   - Implemented proper error handling and validation
   - Added type safety with TypeScript interfaces
   - Implemented request timeout handling

3. **Database Operations** (Completed)
   - Created repository pattern for user operations
   - Implemented transaction support for follow/unfollow
   - Added Google Cloud Storage integration
     - Set up bucket permissions
     - Implemented file upload handler
     - Added file validation
     - Implemented URL generation
     - Added proper indexes for performance optimization
   - Moved StorageService to backend for better security
   - Implemented proper environment variable management with Secret Manager

### Phase 2: Frontend Components (In Progress)

1. **Profile Layout** (Completed)
   - Created ProfilePage component
   - Implemented proper responsive design
   - Added loading states and error boundaries
   - Implemented skeleton loading for better UX
   - Added proper error handling
   - Added click-to-upload profile picture functionality
   - Added file validation and error feedback
   - Updated social links to use YouTube instead of LinkedIn
   - Added placeholder URLs for social links when not provided
   - Added ProfilePictureUpload component for proper upload flow

2. **Profile Sections** (Completed)
   - ProfileHeader - Display profile picture, name, bio
   - StatsSection - Show followers, following, posts count
   - ProfilePictureSection - Handle profile picture uploads
     - Click-to-upload functionality
     - File size validation (2MB limit)
     - File type validation (JPEG, PNG, WebP)
     - Loading states and progress indicator
     - Error handling and feedback
     - Google Cloud Storage integration
   - BioSection - Edit profile bio
   - SocialLinksSection - Manage social media links
   - PrivacySettingsSection - Control profile visibility
   - PostsGrid - Display user posts in grid layout
   - SocialLinks - Display social media links
   - EditProfile - Form for editing profile information
     - Username and display name editing
     - Bio editing (500 character limit)
     - Social links editing (URL validation)
     - Profile picture upload
       - Google Cloud Storage integration
       - File validation (2MB limit, image types)
       - Progress indicator
       - Error handling
     - Creator status toggle
   - Social links editing (URL validation)
   - Profile picture upload
     - Google Cloud Storage integration
     - File validation (2MB limit, image types)
     - Progress indicator
     - Error handling
       - ✅ Error handling
     - ✅ Creator status toggle
   - ❌ Settings - Additional profile settings

3. **Interactive Features** (In Progress)
   - ✅ Follow/Unfollow button with proper state management
   - ✅ Profile picture upload with preview (using Google Cloud Storage)
     - ✅ Image selection and preview
     - ✅ Size validation (2MB max)
     - ✅ Upload to Google Cloud Storage
     - ✅ Progress indicator
     - ✅ Error handling
     - ✅ Bucket-level permissions handling
   - ❌ Social links editing
   - ❌ Social links editing

### Next Steps

1. **Frontend Features**
   - Add settings page for additional profile settings
   - Implement dark mode support
   - Add keyboard navigation support
   - Add accessibility features (ARIA labels, screen reader support)

2. **Backend Improvements**
   - Add proper database indexes for performance
   - Implement caching strategy for profile data
   - Add rate limiting for API endpoints

3. **Testing**
   - Write unit tests for ProfileService
   - Add integration tests for API endpoints
   - Test error handling scenarios
   - Add E2E tests for profile editing flow

4. **Security**
   - Implement proper authentication middleware
   - Add rate limiting for sensitive endpoints
   - Implement proper CORS configuration
   - Add CSRF protection

5. **Performance**
   - Implement image optimization for profile pictures
   - Add lazy loading for profile page components
   - Implement proper caching headers for static assets
   - Bio editing
   - Privacy settings
   - Creator status toggle

### Phase 3: State Management

1. **Contexts**
   - Create ProfileContext for managing profile state
   - Add ProfileProvider component
   - Implement proper state updates and loading states

2. **React Query Integration**
   - Use React Query for all profile data fetching
   - Implement proper caching and refetching
   - Add optimistic updates for interactive features
   - Implement stale-while-revalidate pattern

### Phase 4: UI/UX Improvements

1. **Loading States**
   - Implement skeleton loading for profile sections
   - Add loading indicators for interactive features
   - Proper error states with retry functionality

2. **Error Handling**
   - User-friendly error messages
   - Automatic retries for failed operations
   - Proper error boundaries
   - Toast notifications for user feedback

### Phase 5: Testing

1. **Unit Tests**
   - Test all profile-related components
   - Test API endpoints
   - Test service functions

2. **Integration Tests**
   - Test profile updates
   - Test follow/unfollow functionality
   - Test profile picture upload
   - Test social features

3. **End-to-End Tests**
   - Complete profile flow testing
   - Error scenarios
   - Performance testing

## Current Implementation Status

### Completed Components
1. **ProfileLayout**
   - Responsive design with proper nesting
   - Loading states and error handling
   - Skeleton loading implementation

2. **ProfileHeader**
   - Profile picture display with loading state
   - Display name and bio
   - Follow/Edit buttons with proper state management
   - Creator status indicator

3. **PostsGrid**
   - Grid layout with responsive breakpoints
   - Card-based post display
   - Hover effects and transitions
   - Image preview with CardMedia
   - Proper Grid2 usage from MUI v7

4. **EditProfile**
   - Form for editing profile information
   - Social links editing
   - Loading state management
   - Toast notifications for user feedback
   - Proper form validation

5. **LoadingStateContext**
   - Global loading state management
   - Loading indicators for interactive features
   - Loading state synchronization across components

6. **Toast System**
   - Custom hook for toast notifications
   - Auto-dismiss functionality
   - Success/error/warning/info variants
   - Proper type declarations

### Next Steps
1. Implement profile picture upload functionality
2. Add follow/unfollow functionality
3. Implement social metrics tracking
4. Add privacy settings
5. Implement creator status toggle

## Technical Considerations

1. **Security**
   - Implement proper authentication checks
   - Validate all inputs
   - Sanitize user data
   - Implement rate limiting
   - Add proper CORS configuration

2. **Performance**
   - Implement caching strategy using Redis
   - Optimize database queries
   - Lazy load profile sections
   - Implement proper image optimization
   - Use Google Cloud Storage for file uploads

3. **Scalability**
   - Design for horizontal scaling
   - Implement proper database indexing
   - Use Redis for caching
   - Implement proper error handling

## Files to Modify/Create

### Backend
- `src/services/profileService.ts`
- `src/controllers/profileController.ts`
- `src/routes/profileRoutes.ts`
- `src/models/User.js`
- `src/models/Follower.js`
- `src/models/Post.js`
- `src/models/Notification.js`

### Frontend
- `src/components/profile/ProfileLayout.tsx`
- `src/components/profile/ProfileHeader.tsx`
- `src/components/profile/StatsSection.tsx`
- `src/components/profile/PostsGrid.tsx`
- `src/components/profile/SocialLinks.tsx`
- `src/components/profile/EditProfile.tsx`
- `src/components/profile/ProfileContext.tsx`
- `src/contexts/ProfileContext.tsx`
- `src/types/profile.ts`
- `src/services/profileService.ts`

## Dependencies

1. **Packages**
   - @tanstack/react-query
   - react-dropzone
   - cloudinary-core
   - @heroicons/react
   - react-toastify

2. **Dev Dependencies**
   - @testing-library/react
   - jest
   - supertest
   - mongoose-memory-server

## Next Steps

1. Start with Phase 1 - Backend Setup
   - Create database schema
   - Implement API endpoints
   - Set up services layer

2. Move to Phase 2 - Frontend Components
   - Create basic profile layout
   - Implement profile sections
   - Add loading states

3. Continue with Phase 3 - State Management
   - Set up ProfileContext
   - Integrate React Query
   - Implement state updates

4. Focus on Phase 4 - UI/UX Improvements
   - Add loading states
   - Implement error handling
   - Add user feedback

5. Finally, Phase 5 - Testing
   - Write unit tests
   - Create integration tests
   - Run end-to-end tests

================
File: prisma/schema.prisma
================
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  email         String    @unique
  username      String    @unique
  password      String
  name          String?
  bio           String?
  avatarUrl     String?
  coverUrl      String?
  isCreator     Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  contents      Content[]
  subscriptions Subscription[] @relation("subscriber")
  subscribers   Subscription[] @relation("creator")
  stripeCustomer StripeCustomer?
}

model Content {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  title        String
  description  String
  mediaType    String   // 'video' or 'image'
  mediaUrl     String
  thumbnailUrl String
  isExclusive  Boolean  @default(false)
  likes        Int      @default(0)
  views        Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  creator      User     @relation(fields: [creatorId], references: [id])
  creatorId    String   @db.ObjectId
  categories   Category[] @relation(fields: [categoryIds], references: [id])
  categoryIds  String[] @db.ObjectId
}

model Category {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  name        String    @unique
  description String
  imageUrl    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  contents    Content[] @relation(fields: [contentIds], references: [id])
  contentIds  String[]  @db.ObjectId
}

model Subscription {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  status               String   // 'active', 'cancelled', 'expired'
  stripeSubscriptionId String?  @unique
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  subscriber           User     @relation("subscriber", fields: [userId], references: [id])
  userId              String   @db.ObjectId
  creator             User     @relation("creator", fields: [creatorId], references: [id])
  creatorId           String   @db.ObjectId
}

model SubscriptionPlan {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  description   String
  price         Float
  interval      String   // 'month' or 'year'
  stripePriceId String   @unique
  features      String[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model StripeCustomer {
  id              String @id @default(auto()) @map("_id") @db.ObjectId
  stripeCustomerId String @unique
  
  // Relations
  user            User   @relation(fields: [userId], references: [id])
  userId          String @unique @db.ObjectId
}

================
File: scripts/analyze-bundle.js
================
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const formatBytes = (bytes, decimals = 2) => {
⋮----
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
⋮----
const analyzeDirectory = async (dir) => {
const files = await fs.readdir(dir);
const jsFiles = files.filter(file => file.endsWith('.js'));
console.log('\nBundle Analysis Report');
console.log(''.padEnd(50, '='));
⋮----
const filePath = path.join(dir, file);
const stats = await fs.stat(filePath);
⋮----
fileSizes.push({ name: file, size: fileSize });
⋮----
// Sort by size (descending)
fileSizes.sort((a, b) => b.size - a.size);
// Display files
⋮----
const percentage = ((file.size / totalSize) * 100).toFixed(2);
console.log(`${file.name.padEnd(30)} ${formatBytes(file.size).padStart(12)} (${percentage}%)`);
⋮----
console.log(''.padEnd(50, '-'));
console.log(`Total JavaScript size: ${formatBytes(totalSize).padStart(20)} (100%)`);
// Recommendations
console.log('\nRecommendations:');
if (totalSize > 500000) { // 500KB
console.log('⚠️  Bundle size is large. Consider:');
console.log('   - Implementing code splitting');
console.log('   - Reviewing large dependencies');
⋮----
console.log('✅ Bundle size is within reasonable limits');
⋮----
if (fileSizes.some(f => f.size > 244000)) {
console.log('⚠️  Large individual files detected. Consider:');
console.log('   - Code splitting large components');
console.log('   - Lazy loading non-critical components');
⋮----
console.log('\nNext steps:');
console.log('1. Review the largest bundles for optimization opportunities');
console.log('2. Consider lazy loading for routes and components');
console.log('3. Check for duplicate dependencies');
⋮----
const run = async () => {
⋮----
const distDir = path.join(process.cwd(), 'dist/static');
console.log(`Analyzing bundles in: ${distDir}\n`);
await analyzeDirectory(distDir);
⋮----
console.error('Error analyzing bundle:', error.message);
console.error('\nMake sure to run `npm run build` first');
process.exit(1);
⋮----
run().catch(console.error);

================
File: src/components/auth/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { API_BASE_URL } from '../../config/index';
import { UserProfile } from '../../types/user';
import { logger } from '../../utils/logger';
⋮----
export type AuthErrorType = {
  code: string;
  message: string;
  details?: Record<string, unknown>;
};
export type AuthModalType = 'login' | 'signup';
export interface AuthContextType {
  user: UserProfile | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<UserProfile>;
  logout: () => void;
  updateUser: (updates: Partial<UserProfile>) => void;
  error: AuthErrorType | null;
  isAuthModalOpen: boolean;
  authModalType: AuthModalType;
  openAuthModal: (type: AuthModalType) => void;
  closeAuthModal: () => void;
}
⋮----
export const useAuth = (): AuthContextType =>
export const AuthProvider: React.FC<
⋮----
const login = async (username: string, password: string): Promise<UserProfile> =>
const logout = async () =>
const updateUser = (updates: Partial<UserProfile>) =>
const openAuthModal = (type: AuthModalType) =>
const closeAuthModal = () =>

================
File: src/components/auth/AuthForm.tsx
================
import React from 'react';
import { AlertCircle } from 'lucide-react';
import { FormData, FormErrors } from '../../types/auth';
import { logger } from '../../utils/logger';
export interface AuthFormProps {
  handleSubmit: (e: React.FormEvent) => void;
  isLoading: boolean;
  errors: FormErrors;
  formData: FormData;
  setFormData: React.Dispatch<React.SetStateAction<FormData>>;
  title: string;
}
⋮----
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
const handleFormSubmit = (e: React.FormEvent) =>

================
File: src/components/auth/AuthModal.tsx
================
import React from 'react';
import { useAuth } from './AuthContext';
import { LoginForm } from './LoginForm';
import { SignupForm } from './SignupForm';
import { Modal } from '../common/Modal';
import { logger } from '../../utils/logger';
export const AuthModal = () =>

================
File: src/components/auth/LoginForm.tsx
================
import React, { useState, useCallback } from 'react';
import { useAuth } from './AuthContext';
import { useNavigate } from 'react-router-dom';
import { AlertCircle, X } from 'lucide-react';
import { logger } from '../../utils/logger';
⋮----
interface CountryCode {
  code: string;
  flag: string;
  name: string;
}
⋮----
interface LoginFormProps {
  onClose: () => void;
  openSignupModal: () => void;
}
type LoginMode = 'phone' | 'email';
⋮----
// Form handlers
⋮----
onChange=

================
File: src/components/auth/ProtectedRoute.tsx
================
import React from 'react';
import { Navigate, useLocation, useMatch } from 'react-router-dom';
import { useAuth } from './AuthContext';
import { logger } from '../../utils/logger';
⋮----
export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: UserRole;
  fallbackRoute?: string;
  publicPath?: string;
}
⋮----
// Allow access to public paths without authentication
⋮----
// Check authentication status for protected routes

================
File: src/components/auth/SignupForm.tsx
================
import React, { useState, useCallback } from 'react';
import { useAuth } from './AuthContext';
import { AlertCircle, X } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { logger } from '../../utils/logger';
import SubmitButton from '../common/SubmitButton';
import FormField from '../common/FormField';
import { API_BASE_URL } from '../../config/index';
⋮----
interface SignupRequest {
  email: string;
  username: string;
  password: string;
  isCreator: boolean;
}
interface SignupResponse {
  success: boolean;
  message?: string;
  userId?: string;
}
interface SignupFormProps {
  onClose: () => void;
  openLoginModal?: () => void;
}
interface FormData {
  email: string;
  username: string;
  password: string;
}
interface FormErrors {
  email?: string;
  username?: string;
  password?: string;
  general?: string;
}
⋮----
// Form validation with retry logic
⋮----
// Email validation
⋮----
onChange=

================
File: src/components/common/FormField.tsx
================
import React from 'react';
⋮----
interface FormFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label: string;
  id: string;
  error?: string;
  validationState?: typeof VALIDATION_STATES[keyof typeof VALIDATION_STATES];
  inputType?: typeof INPUT_TYPES[keyof typeof INPUT_TYPES];
}
const FormField: React.FC<FormFieldProps> = ({
  label,
  id,
  error,
  className,
  validationState = VALIDATION_STATES.VALID,
  inputType = INPUT_TYPES.TEXT,
  ...rest
}) =>

================
File: src/components/common/LoadingSpinner.tsx
================
import React from 'react';
⋮----
interface LoadingSpinnerProps {
  size?: typeof SPINNER_SIZES[keyof typeof SPINNER_SIZES];
  color?: typeof SPINNER_COLORS[keyof typeof SPINNER_COLORS];
  className?: string;
}
const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = SPINNER_SIZES.MD,
  color = SPINNER_COLORS.GRAY,
  className = ''
}) =>
⋮----
// Size classes

================
File: src/components/common/Modal.tsx
================
import React from 'react';
⋮----
interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  size?: typeof MODAL_SIZES[keyof typeof MODAL_SIZES];
  variant?: typeof MODAL_VARIANTS[keyof typeof MODAL_VARIANTS];
  title?: string;
  className?: string;
  closeOnOutsideClick?: boolean;
  closeOnEscape?: boolean;
  maxWidth?: string | number;
  sx?: React.CSSProperties;
}
⋮----
// Handle escape key press
⋮----
const handleEscape = (e: KeyboardEvent) =>

================
File: src/components/common/SubmitButton.tsx
================
import React from 'react';
import LoadingSpinner from './LoadingSpinner';
⋮----
interface SubmitButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  isLoading: boolean;
  buttonText: string;
  loadingText: React.ReactNode;
  size?: typeof BUTTON_SIZES[keyof typeof BUTTON_SIZES];
  variant?: typeof BUTTON_VARIANTS[keyof typeof BUTTON_VARIANTS];
}
⋮----
// Validate required props

================
File: src/components/content/components/ContentCard.tsx
================
import { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../auth/AuthContext';
import { logger } from '../../../utils/logger';
import { Skeleton } from '@mui/material';
import { styled } from '@mui/material/styles';
import { ContentCardProps } from './types';
import { IconButton } from '@/components/ui/IconButton';
import { Icons } from '@/components/icons';

================
File: src/components/content/components/ContentCardActions.tsx
================
import React from 'react';
import { Heart, MessageSquare, Share2, Bookmark } from 'lucide-react';
import { Skeleton } from '@mui/material';
interface ContentCardActionsProps {
  initialLikes: number;
  initialLiked: boolean;
  onLike: () => Promise<void>;
  onComment: (text: string) => Promise<void>;
  onShare: () => Promise<void>;
  onBookmark: () => Promise<void>;
  isLoading?: boolean;
}

================
File: src/components/content/components/ContentCardComments.tsx
================
import React from 'react';
import { Comment } from '../types';
import { Avatar } from '@mui/material';
interface ContentCardCommentsProps {
  comments: Comment[];
  onComment: (text: string) => Promise<void>;
  className?: string;
}

================
File: src/components/content/components/ContentCardHeader.tsx
================
import React from 'react';
import { Avatar, Skeleton } from '@mui/material';
interface ContentCardHeaderProps {
  creatorName: string;
  creatorProfilePic: string;
  timestamp: string;
  isSubscribed?: boolean;
  onSubscribe?: () => void;
}
export const ContentCardHeader: React.FC<ContentCardHeaderProps> = ({
  creatorName,
  creatorProfilePic,
  timestamp,
  isSubscribed,
  onSubscribe,
}) =>

================
File: src/components/content/components/ContentCardMedia.tsx
================
import React from 'react';
import { Skeleton } from '@mui/material';
interface ContentCardMediaProps {
  thumbnail: string;
  caption: string;
  onClick: () => void;
  isLoading?: boolean;
}

================
File: src/components/content/components/ContentCardSkeleton.tsx
================
import React from 'react';
import { Skeleton } from '@mui/material';
export const ContentCardSkeleton: React.FC = () =>

================
File: src/components/content/components/ContentDetail.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { useParams } from 'react-router-dom';
import { Play, Heart, Share2, BookmarkPlus } from 'lucide-react';
import { API_BASE_URL } from '../../../config/index';
import { logger } from '../../../utils/logger';
import { Skeleton } from '@mui/material';
export interface ContentData {
  id: string;
  title: string;
  description: string;
  creatorName: string;
  creatorAvatar: string;
  mediaUrl: string;
  likes: number;
  isExclusive: boolean;
  thumbnailUrl: string;
  duration?: string;
  createdAt: string;
  tags?: string[];
}
interface ContentDetailProps {
  className?: string;
}
⋮----
// Fetch content with proper error handling and logging
⋮----
onError=

================
File: src/components/content/components/index.ts
================


================
File: src/components/content/components/types.ts
================
export interface Comment {
  id: string;
  text: string;
  userId: string;
  username: string;
  timestamp: string;
}
export interface ContentCardProps {
  id: string;
  thumbnail: string;
  creatorProfilePic: string;
  creatorName: string;
  timestamp: string;
  caption: string;
  isSubscribed: boolean;
  onSubscribe: () => Promise<void>;
  onClick: () => void;
  initialLikes: number;
  onComment: (text: string) => void;
  initialLiked: boolean;
  comments: Comment[];
  className?: string;
}

================
File: src/components/content/ContentCategories.tsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { Link } from 'react-router-dom';
import { ChevronRight } from 'lucide-react';
import { API_BASE_URL } from '../../config/index';
import { logger } from '../../utils/logger';
export interface Category {
  id: string;
  name: string;
  description: string;
  imageUrl: string;
  contentCount: number;
}
export interface ContentCategoriesProps {
  className?: string;
}
⋮----
// Fetch categories with proper error handling and logging

================
File: src/components/content/ContentUpload.tsx
================
import React, { useRef, useCallback } from 'react';
import { Upload, X, Image as ImageIcon, Film, AlertCircle } from 'lucide-react';
import { useContentUploadForm } from '../../hooks/useContentUploadForm';
import type { FormData } from '../../hooks/useContentUploadForm';
interface ContentUploadComponentProps {
  onError?: (message: string) => void;
}
⋮----
// Notify parent component if there's an error handler
⋮----
// Handle file drop
⋮----
onChange=
⋮----
handleRemoveFile('thumbnail');
⋮----
onClick=
e.stopPropagation();
handleRemoveFile('media');

================
File: src/components/content/ExplorePage.tsx
================
import React from 'react';
import { ContentCard } from './components/ContentCard';
import { Comment } from './components/types';
interface Post {
  id: string;
  thumbnail: string;
  creatorProfilePic: string;
  creatorName: string;
  timestamp: string;
  caption: string;
  initialLikes: number;
  initialLiked: boolean;
  isSubscribed: boolean;
  onSubscribe: () => void;
  onClick: () => void;
  onComment: (text: string) => Promise<void>;
  comments: Comment[];
}
interface ExplorePageProps {
  posts?: Post[];
  onPostClick?: (postId: string) => void;
  onSubscribe?: (postId: string) => void;
  onComment?: (postId: string, comment: string) => void;
}

================
File: src/components/content/InteractionButtons.tsx
================
import React from 'react';
interface InteractionButtonProps {
  icon: 'like' | 'comment' | 'share' | 'bookmark';
  count?: number;
  onClick: () => void;
}

================
File: src/components/content/PostCard.tsx
================
import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import { UserProfile } from '../../types/user';
import { logger } from '../../utils/logger';
import { Skeleton } from '@mui/material';
import { DEFAULT_IMAGES } from '../../config/images';
interface ExtendedUserProfile extends UserProfile {
  id: string;
}
interface Post {
  id: string;
  caption: string;
  mediaUrl: string;
  likes: number;
  comments: number;
  createdAt: string;
  isLiked?: boolean;
  isBookmarked?: boolean;
}
interface PostCardProps {
  user: ExtendedUserProfile;
  post: Post;
  isFollowing: boolean;
  onFollow: () => void;
  onLike: () => void;
  onComment: () => void;
  onShare: () => void;
  onBookmark: () => void;
  className?: string;
}
⋮----
// Validate props
⋮----
onError=

================
File: src/components/content/ProfileSection.tsx
================
import React, { useCallback, useState } from 'react';
import { UserProfile, PartialProfileUpdate } from '../../types/user';
import Card from "@/components/ui/Card";
import Button from "@/components/ui/Button";
import { Icons } from "@/components/icons";
import { ProfilePictureUpload } from '../profile/ProfilePictureUpload';
import { logger } from '../../utils/logger';
import Loading from '@/components/ui/Loading';
import { Alert } from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { Edit as EditIcon } from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { Button as MuiButton } from '@mui/material';
interface SocialLinks {
  twitter?: string;
  youtube?: string;
  instagram?: string;
}
interface ProfileSectionProps {
  user: UserProfile;
  isFollowing: boolean;
  isOwner: boolean;
  onFollow?: () => void;
  onUnfollow?: () => void;
  posts: number;
  followers: number;
  following: number;
  onProfileUpdate?: (updatedUser: UserProfile) => void;
}
⋮----
href={`https://twitter.com/${user.socialLinks.twitter}`}
⋮----
href={`https://youtube.com/${user.socialLinks.youtube}`}
⋮----
href={`https://instagram.com/${user.socialLinks.instagram}`}

================
File: src/components/content/types.ts
================
export interface Comment {
  id: string;
  text: string;
  userId: string;
  username: string;
  timestamp: string;
}
export interface ContentCardProps {
  id: string;
  thumbnail: string;
  creatorProfilePic: string;
  creatorName: string;
  timestamp: string;
  caption: string;
  initialLikes: number;
  initialLiked: boolean;
  isSubscribed: boolean;
  onSubscribe: () => void;
  onClick: () => void;
  onComment: (text: string) => Promise<void>;
  comments: Comment[];
  className?: string;
}

================
File: src/components/creator/CreatorDashboard.tsx
================
import React, { useCallback, useMemo } from 'react';
import { useAuth } from '../auth/AuthContext';
import { CreditCard, Users, TrendingUp, Image } from 'lucide-react';
import { logger } from '../../utils/logger';
interface CreatorDashboardProps {
  className?: string;
}
⋮----
// Memoized stats object
⋮----
// Handle activity click with logging

================
File: src/components/creator/CreatorProfile.tsx
================
import { useState, useCallback, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { logger } from '../../utils/logger';
import { ContentCard } from '../content/ContentCard';
interface Creator {
  id: string;
  username: string;
  name: string;
  email: string;
  bio: string;
  avatarUrl: string;
  coverUrl: string;
  isCreator: boolean;
  subscriptionLevels: SubscriptionLevel[];
  contentCount: number;
  followerCount: number;
  subscriberCount: number;
}
interface SubscriptionLevel {
  id: string;
  name: string;
  description: string;
  price: number;
  features: string[];
  level: 0 | 1 | 2 | 3;
}
⋮----
const fetchCreatorData = async (username: string | undefined): Promise<Creator> =>
⋮----
const fetchAndSetCreator = async () =>
⋮----
{/* Content Grid */}
⋮----
{[1, 2, 3].map((index) => ( // Sample content cards
⋮----
thumbnail={`https://picsum.photos/id/${index}/200/300`}

================
File: src/components/creator/CreatorSubscriptionCard.tsx
================
import React, { useCallback } from 'react';
import { Check } from 'lucide-react';
import type { SubscriptionLevel } from '../../types';
import { logger } from '../../utils/logger';
interface EnhancedSubscriptionLevel extends SubscriptionLevel {
  features: string[];
  name: string;
  price: number;
}
interface CreatorSubscriptionCardProps {
  level: EnhancedSubscriptionLevel;
  creatorName: string;
  currentLevel: number;
  onSubscribe: (level: number) => void;
  className?: string;
}
⋮----
// Handle subscription with error logging

================
File: src/components/layout/AppLayout.tsx
================
import React, { ReactNode } from 'react';
import Sidebar from './Sidebar';
import { Navigation } from './Navigation';
import MoreMenu from './MoreMenu';
import { useUI } from '../../contexts/UIContext';
interface AppLayoutProps {
  children: ReactNode;
}
const AppLayout: React.FC<AppLayoutProps> = (

================
File: src/components/layout/Footer.tsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import { Github, Twitter, Facebook } from 'lucide-react';
export function Footer()

================
File: src/components/layout/Header.tsx
================
import React, { useState, useEffect, useRef } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { logger } from '../../utils/logger';
import { DEFAULT_IMAGES } from '../../config/images';
⋮----
interface HeaderMenuItem {
  label: string;
  onClick: () => void;
  to?: string;
  className: string;
}
⋮----
const handleMenuClick = () =>

================
File: src/components/layout/MoreMenu.tsx
================
import React, { useCallback } from 'react';
import { logger } from '../../utils/logger';
import { SettingsIcon, HelpCircleIcon, ShieldIcon, FileTextIcon } from 'lucide-react';
import { useUI } from '../../contexts/UIContext';
⋮----
interface MoreMenuProps {
  className?: string;
  onMenuItemClick?: (id: string) => void;
}

================
File: src/components/layout/Navigation.tsx
================
import { useCallback } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { useTheme } from '../../theme/hooks/useTheme';
import { DEFAULT_IMAGES } from '../../config/images';
import { useUI } from '../../contexts/UIContext';

================
File: src/components/layout/ProfileLayout.tsx
================
import React from 'react';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import ProfilePage from '../pages/ProfilePage';
import { UserProfile, USER_ROLES } from '../../types/user';
import { DEFAULT_IMAGES } from '../../config/images';
interface ProfileLayoutProps {
  children?: React.ReactNode;
}
export default function ProfileLayout(
⋮----
const handleFollow = async () =>

================
File: src/components/layout/Sidebar.tsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import { useUI } from '../../contexts/UIContext';
const Sidebar: React.FC = () =>

================
File: src/components/pages/FeaturedCard.tsx
================
import React from 'react';
import { motion } from 'framer-motion';
type FeaturedCardProps = {
  profile: {
    profilePicture: string;
    username: string;
    bio: string;
    posts: number;
    followers: number;
    subscribers: number;
  };
  isHighlighted: boolean;
  onButtonClick: (username: string, action: string) => void;
};

================
File: src/components/pages/FeaturedProfilesSection.tsx
================
import React, { useEffect, useState } from 'react';
import FeaturedCard from './FeaturedCard';
import { motion } from 'framer-motion';
import { UserProfile } from '../../types/user';
import LoadingSpinner from '../common/LoadingSpinner';
interface FeaturedProfilesSectionProps {
  profiles: UserProfile[];
  isLoading?: boolean;
  error?: string | null;
  isDark?: boolean;
}
⋮----
const getPosition = (index: number) =>
const handleButtonClick = (username: string, action: string) =>

================
File: src/components/pages/HomePage.tsx
================
import { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { API_BASE_URL } from '../../config/index';
import ErrorBoundary from '../ui/ErrorBoundary';
import Loading from '../ui/Loading';
import { useLoadingState } from '../../contexts/LoadingStateContext';
interface UserProfile {
  username: string;
  email: string;
  posts: number;
  subscribers: number;
  profilePicture?: string;
  name?: string;
  bio?: string;
  followers?: number;
  following?: number;
  isFollowing?: boolean;
}
interface FeaturedProfile {
  username: string;
  name: string;
  bio: string;
  profilePicture: string;
  displayOrder: number;
  isActive: boolean;
}
interface HomePageState {
  profile: UserProfile | null;
  featuredProfiles: FeaturedProfile[];
  isLoading: boolean;
  error: string | null;
  retryCount: number;
  maxRetries: number;
}
⋮----
const fetchProfile = async () =>
const fetchFeaturedProfiles = async () =>
⋮----
const handleRetry = () =>

================
File: src/components/pages/HomePageModern.tsx
================
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { API_BASE_URL } from '../../config/index';
import { useTheme } from '../../theme/hooks/useTheme';
import ErrorBoundary from '../ui/ErrorBoundary';
import { useLoadingContext } from '../../contexts/LoadingContext';
import { USER_ROLES, UserProfile, FeaturedProfile } from '../../types/user';
import Loading from '../ui/Loading';
import FeaturedProfilesSection from './FeaturedProfilesSection';
interface HomePageState {
  profile: UserProfile | null;
  profiles: FeaturedProfile[];
  isLoading: boolean;
  error: string | null;
  retryCount: number;
  maxRetries: number;
}
⋮----
coverPhoto: '', // Default empty cover photo
⋮----
isVerified: false, // Default to not verified
⋮----
const fetchProfile = async () =>
const fetchProfiles = async () =>
⋮----
const rotateProfiles = () =>

================
File: src/components/pages/HomePageNew.tsx
================
import { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { API_BASE_URL } from '../../config/index';
import ErrorBoundary from '../ui/ErrorBoundary';
import Loading from '../ui/Loading';
import { useLoadingState } from '../../contexts/LoadingStateContext';
import Card from "@/components/ui/Card";
import { CardHeader } from "@/components/ui/CardHeader";
import { CardContent } from "@/components/ui/CardContent";
import { CardTitle } from "@/components/ui/CardTitle";
import { CardDescription } from "@/components/ui/CardDescription";
interface UserProfile {
  username: string;
  email: string;
  posts: number;
  subscribers: number;
  profilePicture?: string;
  name?: string;
  bio?: string;
  followers?: number;
  following?: number;
  isFollowing?: boolean;
}
interface FeaturedProfile {
  username: string;
  name: string;
  bio: string;
  profilePicture: string;
  displayOrder: number;
  isActive: boolean;
}
interface HomePageState {
  profile: UserProfile | null;
  featuredProfiles: FeaturedProfile[];
  isLoading: boolean;
  error: string | null;
  retryCount: number;
  maxRetries: number;
}
⋮----
const fetchProfile = async () =>
const fetchFeaturedProfiles = async () =>
⋮----
const handleRetry = () =>

================
File: src/components/pages/ProfilePage.tsx
================
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Button,
  Typography,
  Container,
  CircularProgress,
  Tabs,
  Tab,
  styled
} from '@mui/material';
import GridOnIcon from '@mui/icons-material/GridOn';
import BookmarkBorderIcon from '@mui/icons-material/BookmarkBorder';
import Settings from '@mui/icons-material/Edit';
import VerifiedIcon from '@mui/icons-material/Verified';
import { useAuth } from '../auth/AuthContext';
import profileService from '../../services/profileService';
import { logger } from '../../utils/logger';
import { useLoadingContext } from '../../contexts/LoadingContext';
import { useQuery, useQueryClient, UseQueryOptions } from '@tanstack/react-query';
import type { ApiResponse, UserProfile } from '../../types/user';
import EditProfile from '../profile/EditProfile';
import ProfilePictureUpload from '../profile/ProfilePictureUpload';
⋮----
interface ProfilePageParams {
  username: string;
}
⋮----
const handleTabChange = (_event: React.SyntheticEvent, newValue: number) =>
const handleEditProfile = () =>
const handleCloseEditModal = () =>
const handleProfileUpdate = async () =>
const handleFollow = async () =>
const handleProfilePictureUpload = async (file: File) =>
⋮----
{/* Upload Status Feedback */}

================
File: src/components/pages/SettingsPage.tsx
================
import { useAuth } from '../auth/AuthContext';
import { Container, Typography, Box, Button, List, ListItem, ListItemText, ListItemIcon, Divider, Paper, styled, ListItemButton } from '@mui/material';
import Grid from '@mui/material/Grid';
import { useTheme as useMuiTheme } from '@mui/material/styles';
import {
  AccountCircle,
  Lock,
  Notifications,
  PrivacyTip,
  Logout,
} from '@mui/icons-material';
import { ThemeSettings } from '../settings/ThemeSettings';
⋮----
const handleLogout = () =>

================
File: src/components/profile/form/ProfileFormState.ts
================
import { ProfileFormData, ProfileErrors, EditProfileProps } from '../types';
import { ProfileFormValidator } from './ProfileFormValidator';
export class ProfileFormState
⋮----
constructor(initialData: EditProfileProps['user'])
getFormData(): ProfileFormData
getErrors(): ProfileErrors
isLoading(): boolean
setLoading(isLoading: boolean): void
updateField(name: keyof ProfileFormData, value: string | boolean): void
validate(): boolean

================
File: src/components/profile/form/ProfileFormUI.tsx
================
import React from 'react';
import { Box, TextField, Typography, Card, CardContent, styled, FormControl, InputLabel, Select, MenuItem } from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { ProfileFormData, ProfileErrors } from '../types';
interface ProfileFormUIProps {
  formData: ProfileFormData;
  errors: ProfileErrors;
  loading: boolean;
  onInputChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onCreatorToggle: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onSubmit: (e: React.FormEvent) => void;
}

================
File: src/components/profile/form/ProfileFormValidator.ts
================
import { ProfileFormData, ProfileErrors } from '../types';
export class ProfileFormValidator
⋮----
static validate(formData: ProfileFormData): ProfileErrors
static isValid(errors: ProfileErrors): boolean

================
File: src/components/profile/CoverPhotoUpload.tsx
================
import React, { useCallback, useRef } from 'react';
import { useDropzone } from 'react-dropzone';
import { Box, IconButton, CircularProgress, Tooltip } from '@mui/material';
import { CloudUpload as CloudUploadIcon, Close as CloseIcon } from '@mui/icons-material';
interface CoverPhotoUploadProps {
  isVisible: boolean;
  isUploading?: boolean;
  onUpload: (file: File) => Promise<string>;
}
⋮----
const handleFileInputChange = (event: React.ChangeEvent<HTMLInputElement>) =>
const handleUploadClick = () =>
const handleUpload = async (file: File) =>

================
File: src/components/profile/EditProfile.tsx
================
import React from 'react';
import { useToast } from '@/hooks/useToast';
import { ProfileFormData } from './types';
import { UserProfile } from '../../types/user';
import { EditProfileModal } from './EditProfileModal';
import { useProfileUpdate } from '../../hooks/useProfileUpdate';
interface EditProfileProps {
  user: UserProfile;
  onProfileUpdate?: () => void;
  onClose?: () => void;
}
const EditProfile: React.FC<EditProfileProps> = (
⋮----
const handleSave = async (formData: ProfileFormData) =>
const handleClose = () =>

================
File: src/components/profile/EditProfileModal.tsx
================
import React from 'react';
import { Modal } from '../common/Modal';
import { ProfilePictureUpload } from './ProfilePictureUpload';
import { ProfileFormUI } from './form/ProfileFormUI';
import { ProfileFormData, ProfileErrors } from './types';
import { UserProfile } from '../../types/user';
import { Box, CircularProgress } from '@mui/material';
import { logger } from '../../utils/logger';
import profileService from '../../services/profileService';
interface EditProfileModalProps {
  isOpen: boolean;
  onClose: () => void;
  user: UserProfile;
  onSave: (updates: ProfileFormData) => Promise<void>;
  onProfilePictureUpdate: (imageUrl: string) => Promise<boolean>;
  loading: boolean;
  error?: string;
}
⋮----
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Type guard to ensure name is a valid key
⋮----
// Enforce max length for bio
⋮----
const handleSubmit = async (e: React.FormEvent) =>
const handleModalClose = () =>
⋮----
onUpload=
onUploadSuccess=

================
File: src/components/profile/PostsGrid.tsx
================
import React from 'react';
import { Box, Typography, Card, CardContent, CardMedia } from '@mui/material';
import {Grid} from '@mui/material/Grid';
import { styled } from '@mui/material/styles';
interface Post {
  id: string;
  title: string;
  description: string;
  imageUrl: string;
  createdAt: string;
}
interface PostsGridProps {
  posts: Post[];
}
⋮----
const PostsGrid: React.FC<PostsGridProps> = (

================
File: src/components/profile/ProfileHeader.tsx
================
import React, { useState, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  IconButton,
  Tooltip,
  CircularProgress,
} from '@mui/material';
import {
  Edit as EditIcon,
  PersonAdd as PersonAddIcon,
  PersonRemove as PersonRemoveIcon,
  Check as CheckIcon,
  Link as LinkIcon,
  Instagram as InstagramIcon,
  Twitter as TwitterIcon,
  YouTube as YouTubeIcon,
  Language as WebsiteIcon,
} from '@mui/icons-material';
import { UserProfile } from '../../types/user';
import { useLoading } from '../../contexts/LoadingContext';
import { ProfilePictureUpload } from './ProfilePictureUpload';
interface ProfileHeaderProps {
  user: UserProfile;
  isOwner: boolean;
  onFollow?: () => void;
  onUnfollow?: () => void;
  onProfileUpdate?: (updates: Partial<UserProfile>) => Promise<void>;
}
⋮----
{/* User Info */}

================
File: src/components/profile/ProfileLayout.tsx
================
import React, { useCallback, useState } from 'react';
import { Box, Container, Alert } from '@mui/material';
import { ProfileHeader } from './ProfileHeader';
import StatsSection from './StatsSection';
import PostsGrid from './PostsGrid';
import SocialLinks from './SocialLinks';
import EditProfile from './EditProfile';
import type { UserProfile, PartialProfileUpdate } from '../../types/user';
import { profileService } from '../../services/profileService';
import { logger } from '../../utils/logger';
import { useLoadingState } from '../../contexts/LoadingStateContext';
interface ProfileLayoutProps {
  initialUser: UserProfile;
  isOwner: boolean;
  onFollow?: () => void;
  onUnfollow?: () => void;
  onProfileUpdate?: (updates: PartialProfileUpdate) => Promise<void>;
}
⋮----
// Start loading state
⋮----
// Validate updates
⋮----
// End loading state

================
File: src/components/profile/ProfilePictureUpload.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import {
  Box,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Alert,
  keyframes,
  styled as muiStyled,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import { logger } from '@/utils/logger';
export interface UploadResponse {
  success: boolean;
  imageUrl?: string;
  url?: string;
  error?: string;
}
export interface ProfilePictureUploadProps {
  isVisible?: boolean;
  isUploading?: boolean;
  currentImageUrl?: string;
  onUpload: (file: File) => Promise<UploadResponse>;
  onUploadSuccess?: (data: { imageUrl: string }) => Promise<boolean>;
  showEditOnHover?: boolean;
  className?: string;
}
⋮----
const validateFile = (file: File): string | null =>
⋮----
// Validate file type
⋮----
// Check specific image types
⋮----
const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Reset the input value to allow selecting the same file again
⋮----
const handleClick = () =>

================
File: src/components/profile/SocialLinks.tsx
================
import React from 'react';
import { Box, Typography, Link, Card, CardContent, styled } from '@mui/material';
import { OpenInNew } from '@mui/icons-material';
interface SocialLinksProps {
  socialLinks: {
    website?: string;
    twitter?: string;
    youtube?: string;
  };
}
⋮----
const SocialLinks: React.FC<SocialLinksProps> = (
⋮----
const renderSocialLink = (label: string, url: string | undefined) =>
⋮----

================
File: src/components/profile/StatsSection.tsx
================
import React from 'react';
import { Box, Typography, Card, CardContent } from '@mui/material';
import { Grid as MuiGrid } from '@mui/material/Grid';
import { styled } from '@mui/material/styles';
interface StatsSectionProps {
  user: any;
}
⋮----
const StatsSection: React.FC<StatsSectionProps> = (

================
File: src/components/profile/types.ts
================
export interface ProfileFormData {
  displayName: string;
  bio: string;
  website: string;
  twitter: string;
  youtube: string;
  isCreator: boolean;
}
export interface ProfileErrors {
  displayName: string;
  bio: string;
  website: string;
  twitter: string;
  youtube: string;
}
export interface UserSocialLinks {
  website?: string;
  twitter?: string;
  youtube?: string;
}
export interface UserProfile {
  username: string;
  displayName: string;
  bio: string;
  profilePicture?: string;
  socialLinks?: UserSocialLinks;
  isCreator: boolean;
  following?: number;
  followers?: number;
  posts?: number;
}
export interface EditProfileProps {
  user: UserProfile;
  onProfileUpdate?: () => void;
}
export interface ProfileUpdateData {
  displayName: string;
  bio: string;
  socialLinks: UserSocialLinks;
  isCreator: boolean;
}

================
File: src/components/settings/ThemeSettings.tsx
================
import React from 'react';
import { useTheme } from '../../theme/hooks/useTheme';
import ThemeToggle from '../ui/ThemeToggle';
export const ThemeSettings: React.FC = () =>

================
File: src/components/subscription/SubscriptionPlans.tsx
================
import { useState, useEffect } from 'react';
import { Check } from 'lucide-react';
import { useAuth } from '../auth/AuthContext';
import { API_BASE_URL } from '../../config/index';
interface Plan {
  id: string;
  name: string;
  price: number;
  interval: 'month' | 'year';
  features: string[];
  isPopular?: boolean;
}
⋮----
const handleSubscribe = async (planId: string) =>

================
File: src/components/ui/Avatar.tsx
================
import React from 'react';
import { DEFAULT_IMAGES } from '../../config/images';
interface AvatarProps {
  src?: string;
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
  alt?: string;
}
const Avatar: React.FC<AvatarProps> = ({
  src,
  size = 'md',
  className = '',
  alt = 'User avatar',
}) =>

================
File: src/components/ui/Button.tsx
================
import React from 'react';
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  children: React.ReactNode;
  onClick?: () => void;
  type?: 'button' | 'submit' | 'reset';
  disabled?: boolean;
}
const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  className = '',
  children,
  onClick,
  type = 'button',
  disabled = false,
}) =>

================
File: src/components/ui/Card.tsx
================
import React from 'react';
interface CardProps {
  variant?: 'default' | 'elevated' | 'bordered';
  className?: string;
  children: React.ReactNode;
}
const Card: React.FC<CardProps> = ({
  variant = 'default',
  className = '',
  children,
}) =>

================
File: src/components/ui/CardContent.tsx
================
import React from 'react';
interface CardContentProps {
  className?: string;
  children: React.ReactNode;
}
export const CardContent: React.FC<CardContentProps> = ({
  className = '',
  children,
}) =>

================
File: src/components/ui/CardDescription.tsx
================
import React from 'react';
interface CardDescriptionProps {
  className?: string;
  children: React.ReactNode;
}
export const CardDescription: React.FC<CardDescriptionProps> = ({
  className = '',
  children,
}) =>

================
File: src/components/ui/CardHeader.tsx
================
import React from 'react';
interface CardHeaderProps {
  className?: string;
  children: React.ReactNode;
}
export const CardHeader: React.FC<CardHeaderProps> = ({
  className = '',
  children,
}) =>

================
File: src/components/ui/CardTitle.tsx
================
import React from 'react';
interface CardTitleProps {
  className?: string;
  children: React.ReactNode;
}
export const CardTitle: React.FC<CardTitleProps> = ({
  className = '',
  children,
}) =>

================
File: src/components/ui/ErrorBoundary.tsx
================
import { Component, ErrorInfo, ReactNode } from 'react';
import { logger } from '../../utils/logger';
interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}
⋮----
public static getDerivedStateFromError(error: Error): ErrorBoundaryState
public componentDidCatch(error: Error, errorInfo: ErrorInfo): void

================
File: src/components/ui/Icon.tsx
================
import React from 'react';
interface IconProps {
  name: string;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  onClick?: () => void;
}

================
File: src/components/ui/IconButton.tsx
================
import React from 'react';
import { styled } from '@mui/material/styles';
interface IconButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  active?: boolean;
  count?: number;
}
⋮----
export const IconButton: React.FC<IconButtonProps> = ({
  children,
  active = false,
  count,
  ...props
}) => (
  <StyledButton active={active} {...props}>
    {children}
    {count !== undefined && <Count>{count}</Count>}
  </StyledButton>
);

================
File: src/components/ui/Loading.tsx
================
import React from 'react';
import { CircularProgress } from '@mui/material';
import { useLoadingContext } from '../../contexts/LoadingContext';
import SkeletonLoader from './SkeletonLoader';
interface LoadingProps {
  size?: number;
  color?: 'primary' | 'secondary' | 'inherit';
  className?: string;
  variant?: 'text' | 'rectangular';
  width?: string | number;
  height?: number;
  showSpinner?: boolean;
}

================
File: src/components/ui/SkeletonLoader.tsx
================
import React from 'react';
import { styled } from '@mui/material/styles';
import { Box, Typography } from '@mui/material';
interface SkeletonLoaderProps {
  height?: number;
  width?: string | number;
  variant?: 'text' | 'rectangular' | 'circular';
  className?: string;
}

================
File: src/components/ui/ThemeToggle.tsx
================
import React from 'react';
import { useTheme } from '../../theme/hooks/useTheme';
interface ThemeToggleProps {
  showLabel?: boolean;
  className?: string;
  size?: 'sm' | 'md' | 'lg';
}

================
File: src/components/ui/UploadButton.tsx
================
import React, { useState } from 'react';
import Button from './Button';
import { Icons } from '../icons';
interface UploadButtonProps {
  onFileSelect: (file: File) => void;
  className?: string;
}
const UploadButton: React.FC<UploadButtonProps> = (
⋮----
const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) =>
const handleDrag = (e: React.DragEvent<HTMLDivElement>) =>
const handleDrop = (e: React.DragEvent<HTMLDivElement>) =>

================
File: src/components/icons.tsx
================
import { LucideProps } from "lucide-react"

================
File: src/components/LoadingSpinner.tsx
================
import React from 'react';
const LoadingSpinner: React.FC = () =>

================
File: src/components/Toast.tsx
================
import React from 'react';
import { Snackbar, Alert } from '@mui/material';
import { useToast } from '../hooks/useToast';
const Toast: React.FC = () =>

================
File: src/components/UserProfilePage.tsx
================
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { useToast } from '../hooks/useToast';
import { UserProfile, SocialLinks, ProfileInput } from '../types/user';
import { profileService } from '../services/profileService';
import { logger } from '../utils/logger';
import LoadingSpinner from '../components/LoadingSpinner';
import { Edit as EditIcon } from '@mui/icons-material';
import { Button as MuiButton } from '@mui/material';
import ProfilePictureUpload from './profile/ProfilePictureUpload';
import { useAuth } from './auth/AuthContext';
interface UserProfilePageProps {
  username: string;
  isFollowing: boolean;
  onFollow: () => Promise<void>;
  statsData: {
    posts: number;
    followers: number;
    following: number;
  };
}
⋮----
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>
const handleSubmit = async (e: React.FormEvent) =>
⋮----
const fetchProfile = async () =>
⋮----
onUpload=

================
File: src/config/images.ts
================


================
File: src/config/index.ts
================


================
File: src/contexts/LoadingContext.tsx
================
import { ReactNode, createContext, useContext } from 'react';
import { useLoading } from '../hooks/useLoading';
import type { UseLoadingOptions } from '../hooks/useLoading';
⋮----
interface LoadingContextType extends ReturnType<typeof useLoading> {
  loadingState?: {
    isLoading: boolean;
    error: Error | null;
  };
  setLoadingState?: (state: { isLoading: boolean; error?: Error | null }) => void;
}
⋮----
export const LoadingProvider = ({
  children,
  ...options
}:
export const useLoadingContext = () =>
export const useLoadingState = () =>

================
File: src/contexts/UIContext.tsx
================
import React, { createContext, useContext, useState, useCallback } from 'react';
interface UIContextType {
  isSidebarOpen: boolean;
  isMoreMenuOpen: boolean;
  isMobileMenuOpen: boolean;
  toggleSidebar: () => void;
  toggleMoreMenu: () => void;
  toggleMobileMenu: () => void;
  closeAllMenus: () => void;
  openMoreMenu: () => void;
  closeMoreMenu: () => void;
}
⋮----
export const UIProvider: React.FC<
export const useUI = (): UIContextType =>

================
File: src/hooks/useApi.ts
================
import { useState, useCallback, useRef } from 'react';
interface ApiResponse<T> {
  data: T | null;
  error: string | null;
  status?: number;
}
interface ApiRequestOptions<U = unknown> {
  body?: U;
  headers?: Record<string, string>;
  signal?: AbortSignal;
}
export function useApi<T, U = unknown>(baseUrl: string)

================
File: src/hooks/useAuth.ts
================
import { useState, useEffect, useCallback } from 'react';
import axios, { AxiosError } from 'axios';
import { logger } from '../utils/logger';
import type { UserProfile } from '../types/user';
interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  loading: boolean;
}
interface AuthResponse {
  token: string;
  user: UserProfile;
}
interface LoginCredentials {
  identifier: string;
  password: string;
  authMethod: 'password' | 'otp';
}
interface SignupData {
  username: string;
  email: string;
  password: string;
  isCreator: boolean;
  displayName: string;
  profilePic: string;
}
export const useAuth = () =>

================
File: src/hooks/useContentUploadForm.ts
================
import React, { useState, ChangeEvent, useCallback, useEffect, useMemo } from 'react';
import { useAuth } from '../components/auth/AuthContext';
import apiService from '../services/apiService';
import type { AxiosError, AxiosProgressEvent, AxiosResponse } from 'axios';
interface FormData {
  title: string;
  description: string;
  requiredLevel: 0 | 1 | 2 | 3;
  mediaType: 'image' | 'video';
  thumbnailFile?: File;
  mediaFile?: File;
}
interface PreviewUrls {
  thumbnail?: string;
  media?: string;
}
interface FormErrors {
  title?: string;
  description?: string;
  mediaType?: string;
  thumbnail?: string;
  media?: string;
  general?: string;
}
interface UploadResponseData {
  message: string;
  contentId: string;
  content: {
    id: string;
    title: string;
    description: string;
    mediaType: 'image' | 'video';
    mediaUrl: string;
    thumbnailUrl: string;
    requiredLevel: number;
    createdAt: string;
    updatedAt: string;
  };
}
interface UploadErrorData {
  message: string;
  errors?: Array<{
    param: keyof FormData;
    msg: string;
  }>;
}
type ProgressHandler = (progressEvent: AxiosProgressEvent) => void;
⋮----
export function useContentUploadForm()
⋮----
const onUploadProgress: ProgressHandler = (progressEvent) =>
⋮----
// Create reset form callback
⋮----
// Clean up any existing preview URLs

================
File: src/hooks/useForm.ts
================
import { useState, ChangeEvent, useCallback } from 'react';
export interface ValidationRule<T> {
  validator: (value: T[keyof T], values: T) => string | undefined;
  validateOnChange?: boolean;
  validateOnBlur?: boolean;
}
export interface FormConfig<T> {
  initialValues: T;
  validationRules?: Partial<{
    [K in keyof T]: ValidationRule<T>[] | ValidationRule<T>;
  }>;
  onSubmit?: (values: T) => void | Promise<void>;
  validateOnSubmit?: boolean;
  validateOnChange?: boolean;
  validateOnBlur?: boolean;
}
export interface FormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>> & { general?: string };
  isSubmitting: boolean;
  isTouched: boolean;
  isValid: boolean;
  touched: Partial<Record<keyof T, boolean>>;
  handleChange: (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => void;
  handleBlur: (field: keyof T) => void;
  handleSubmit: (e: React.FormEvent) => Promise<void>;
  resetForm: () => void;
  setFieldValue: <K extends keyof T>(field: K, value: T[K]) => void;
  setFieldError: (field: keyof T, error: string | undefined) => void;
  validateForm: () => boolean;
}
export function useForm<T extends Record<string, any>>(config: FormConfig<T>): FormState<T>

================
File: src/hooks/useLoading.ts
================
import { useState, useCallback, useMemo } from 'react';
type LoadingState = {
  isLoading: boolean;
  error: Error | null;
  startTime: number | null;
  endTime: number | null;
};
type LoadingStates = Record<string, LoadingState>;
export interface UseLoadingOptions {
  trackTime?: boolean;
  resetErrorOnStart?: boolean;
  initialStates?: LoadingStates;
}
export function useLoading<T extends string = string>(options: UseLoadingOptions =

================
File: src/hooks/useProfile.ts
================
import { useState, useEffect, useCallback, useMemo } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { UserProfile, UserStats, SocialLinks } from '../types/user';
import { profileService } from '../services/profileService';
import { useAuth } from '../components/auth/AuthContext';
import { useLoadingContext } from '../contexts/LoadingContext';
interface UseProfileReturn {
  profile: UserProfile | null;
  isLoading: boolean;
  error: Error | null;
  isCurrentUser: boolean;
  isFollowing: boolean;
  isCreator: boolean;
  stats: UserStats;
  socialLinks: SocialLinks;
  refreshProfile: () => Promise<void>;
  followUser: () => Promise<void>;
  unfollowUser: () => Promise<void>;
  updateProfile: (updates: Partial<UserProfile>) => Promise<UserProfile>;
  uploadAvatar: (file: File) => Promise<string>;
  uploadCoverPhoto: (file: File) => Promise<string>;
  isUpdating: boolean;
  isUploading: boolean;
}
export const useProfile = (username?: string): UseProfileReturn =>
⋮----
// State management
⋮----
/**
   * Fetches the user profile data
   * @private
   */

================
File: src/hooks/useProfileUpdate.ts
================
import { useCallback, useState } from 'react';
import { useToast } from './useToast';
import profileService from '../services/profileService';
import { logger } from '../utils/logger';
import { UserProfile } from '../types/user';
export interface ProfileUpdateData {
  displayName?: string;
  bio?: string;
  website?: string;
  twitter?: string;
  youtube?: string;
  isCreator?: boolean;
  profilePicture?: string;
}
export const useProfileUpdate = (user: UserProfile, onSuccess?: () => void) =>

================
File: src/hooks/useToast.ts
================
import { useState } from 'react';
export interface Toast {
  message: string;
  severity: 'success' | 'error' | 'warning' | 'info';
}
export interface UseToastReturn {
  toast: Toast | null;
  showToast: (message: string, severity: Toast['severity']) => void;
}
export const useToast = (): UseToastReturn =>
⋮----
const showToast = (message: string, severity: Toast['severity']) =>

================
File: src/server/config/db.js
================
require('dotenv').config({ path: '../../.env' });
const connectDB = async () => {
⋮----
throw new Error('MONGODB_URI is not defined in environment variables');
⋮----
const conn = await mongoose.connect(process.env.MONGODB_URI);
logger.info(`MongoDB Connected: ${conn.connection.host}`);
⋮----
logger.error(`MongoDB connection error: ${err.message}`);
process.exit(1);

================
File: src/server/config/email.js
================
require('dotenv').config();
const transporter = nodemailer.createTransport({
⋮----
const sendVerificationEmail = async (to, token) => {
⋮----
await transporter.sendMail({
⋮----
const sendPasswordResetEmail = async (to, token) => {

================
File: src/server/config/logger.js
================
const myFormat = printf(({ level, message, timestamp }) => {
⋮----
const logger = winston.createLogger({
⋮----
format: combine(
timestamp(),
⋮----
json()
⋮----
new winston.transports.File({ filename: 'error.log', level: 'error' }),
new winston.transports.File({ filename: 'combined.log' })
⋮----
logger.add(new winston.transports.Console({
⋮----
colorize(),
simple(),
⋮----
logger.info = (message, meta = {}) => {
logger.log('info', message, meta);
⋮----
logger.error = (message, meta = {}) => {
logger.log('error', message, meta);
⋮----
logger.warn = (message, meta = {}) => {
logger.log('warn', message, meta);
⋮----
logger.debug = (message, meta = {}) => {
logger.log('debug', message, meta);

================
File: src/server/config/socket.js
================
const initializeSocket = (server) => {
const io = new Server(server, {
⋮----
io.use((socket, next) => {
⋮----
return next(new Error('Authentication error'));
⋮----
const decoded = jwt.verify(token, process.env.JWT_SECRET);
⋮----
next();
⋮----
next(new Error('Authentication error'));
⋮----
io.on('connection', (socket) => {
console.log('User connected:', socket.user.userId);
socket.join(socket.user.userId);
socket.on('private-message', async (data) => {
⋮----
io.to(recipientId).emit('new-message', {
⋮----
socket.on('content-update', (data) => {
io.to(data.creatorId).emit('creator-content-update', data);
⋮----
socket.on('disconnect', () => {
console.log('User disconnected:', socket.user.userId);

================
File: src/server/config/stripe.js
================
const createCheckoutSession = async (customerId, priceId) => {
const session = await stripe.checkout.sessions.create({
⋮----
const createCustomer = async (email, name) => {
const customer = await stripe.customers.create({
⋮----
const handleWebhook = async (event) => {

================
File: src/server/controllers/postController.js
================
const getUserPosts = async (req, res) => {
⋮----
const user = await User.findOne({ username });
⋮----
return res.status(404).json({
⋮----
const posts = await Post.find({ userId: user._id })
.sort({ createdAt: -1 })
.populate('userId', 'username profilePicture')
.select('-__v')
.select('-createdAt')
.select('-updatedAt');
const formattedPosts = posts.map(post => ({
id: post._id.toString(),
⋮----
createdAt: post.createdAt ? post.createdAt.toISOString() : new Date().toISOString(),
⋮----
id: post.userId._id.toString(),
⋮----
res.status(200).json(formattedPosts);
⋮----
console.error('Error fetching user posts:', error);
res.status(500).json({

================
File: src/server/controllers/userController.js
================
const getCurrentUserProfile = async (req, res) => {
⋮----
return res.status(401).json({
⋮----
const ensureAbsoluteUrl = (url) => {
⋮----
if (url.startsWith('http')) return url;
if (url.startsWith('/')) return url;
⋮----
profilePicture: ensureAbsoluteUrl(user.profilePicture),
⋮----
const [postsCount, followersCount, followingCount] = await Promise.all([
Post.countDocuments({ userId: user._id }),
User.countDocuments({ following: user._id }),
User.countDocuments({ followers: user._id })
⋮----
res.status(200).json(userProfile);
⋮----
console.error('Error fetching current user profile:', error);
res.status(500).json({
⋮----
const getUserProfile = async (req, res) => {
⋮----
const user = await User.findOne({ username })
.select('-password')
.select('-googleId')
.select('-__v')
.select('-createdAt')
.select('-updatedAt');
⋮----
return res.status(404).json({
⋮----
logger.info('User profile picture data:', {
⋮----
processedUrl: ensureAbsoluteUrl(user.profilePicture),
⋮----
id: user._id.toString(),
userId: user._id.toString(),
⋮----
// Ensure profile picture URL is properly formatted
⋮----
createdAt: user.createdAt || new Date(),
updatedAt: user.updatedAt || new Date()
⋮----
const [postCount, followerCount, followingCount] = await Promise.all([
⋮----
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
res.setHeader('Access-Control-Allow-Credentials', true);
res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
res.setHeader('Pragma', 'no-cache');
res.setHeader('Expires', '0');
logger.info('Sending user profile response', {
⋮----
headers: res.getHeaders()
⋮----
return res.status(200).json(userProfile);
⋮----
console.error('Error fetching user profile:', error);
⋮----
const getUserPosts = async (req, res) => {
⋮----
const user = await User.findOne({ username });
⋮----
return res.status(404).json({ error: 'User not found' });
⋮----
const posts = await Post.find({ userId: user._id })
.sort({ createdAt: -1 })
.populate('userId', 'username profilePicture');
res.status(200).json(posts);
⋮----
console.error('Error fetching user posts:', error);
res.status(500).json({ error: 'Server error' });
⋮----
const getUserStats = async (req, res) => {
⋮----
res.status(200).json({
⋮----
lastUpdated: new Date().toISOString()
⋮----
console.error('Error fetching user stats:', error);
⋮----
const uploadProfilePicture = async (req, res, next) => {
⋮----
logger.error('Invalid username parameter', {
⋮----
return res.status(400).json({
⋮----
logger.error('No file uploaded in request', {
⋮----
logger.error('Invalid file properties', {
⋮----
fileProps: Object.keys(file),
⋮----
logger.info('Processing file upload', {
⋮----
const uploadResponse = await uploadFile(username, {
⋮----
logger.error('Failed to upload to storage', {
⋮----
return res.status(500).json({
⋮----
logger.error('User not found', { username });
⋮----
const oldFileName = oldPictureUrl ? oldPictureUrl.split('/').pop() : null;
⋮----
await user.save();
⋮----
const oldFileName = oldPictureUrl.split('/').pop();
⋮----
await deleteFile(oldFileName);
logger.info('Old profile picture deleted', { username, oldFileName });
⋮----
logger.error('Failed to delete old profile picture', {
⋮----
logger.info('Profile picture updated successfully', {
⋮----
return res.json({
⋮----
logger.error('Failed to update user profile with new picture', {
⋮----
logger.error('Profile picture upload error', {

================
File: src/server/middlewares/auth.js
================
require('dotenv').config();
⋮----
const auth = (roles = []) => {
⋮----
logger.info('Auth middleware executed');
⋮----
const token = authHeader ? authHeader.replace('Bearer ', '') : null;
⋮----
logger.warn('Auth middleware: No token provided');
return res.status(401).json({ message: 'No token, authorization denied' });
⋮----
const decoded = jwt.verify(token, process.env.JWT_SECRET);
⋮----
const user = await User.findById(decoded.userId).select('username');
⋮----
logger.warn('User not found in database', { userId: decoded.userId });
return res.status(401).json({ message: 'User not found' });
⋮----
logger.error('Error looking up user', {
⋮----
return res.status(500).json({ message: 'Error authenticating user' });
⋮----
logger.warn('Auth middleware: No role in token');
return res.status(403).json({ message: 'Insufficient permissions' });
⋮----
if (roles.length > 0 && !roles.includes(decoded.role)) {
logger.warn('Auth middleware: Insufficient permissions');
⋮----
next();
⋮----
logger.error('Auth middleware: Token verification failed', err);
return res.status(401).json({ message: 'Invalid token' });

================
File: src/server/middlewares/authorization.js
================
const isOwner = (idParam = 'id') => {
⋮----
logger.warn('Unauthorized access attempt - no user', {
⋮----
return res.status(401).json({
⋮----
logger.warn('Forbidden: Invalid user identifier', {
⋮----
return res.status(403).json({
⋮----
logger.warn('Forbidden: User does not own this resource', {
⋮----
next();
⋮----
logger.error('Authorization error', {
⋮----
return res.status(500).json({

================
File: src/server/middlewares/errorHandler.js
================
const errorHandler = (err, req, res, next) => {
logger.error('Error in request', {
⋮----
logger.warn('Headers already sent, skipping error response', {
⋮----
return res.status(413).json({
⋮----
return res.status(400).json({
⋮----
const errors = Object.values(err.errors).map(e => e.message);
logger.warn('Mongoose validation error', {
⋮----
error: errors.join(', ')
⋮----
const field = Object.keys(err.keyValue)[0]
return res.status(400).json({message: `${field} already exists`})
⋮----
logger.error({
⋮----
res.status(err.status || 500).json({

================
File: src/server/middlewares/requestLogger.js
================
const requestLogger = morgan('combined', {
⋮----
write: (message) => {
logger.info('New request received');
logger.info(message.trim());

================
File: src/server/middlewares/security.js
================
const limiter = rateLimit({
⋮----
const sanitizeInput = (req, res, next) => {
⋮----
Object.keys(req.body).forEach(key => {
⋮----
req.body[key] = xss(req.body[key]);
⋮----
next();
⋮----
const securityHeaders = helmet({

================
File: src/server/models/Content.js
================
const ContentSchema = new mongoose.Schema({
⋮----
module.exports = mongoose.model('Content', ContentSchema);

================
File: src/server/models/FeaturedProfile.js
================
const FeaturedProfileSchema = new mongoose.Schema({
⋮----
FeaturedProfileSchema.pre('save', function(next) {
this.lastUpdated = new Date();
next();
⋮----
const FeaturedProfile = mongoose.model('FeaturedProfile', FeaturedProfileSchema);

================
File: src/server/models/Post.js
================
const PostSchema = new mongoose.Schema({
⋮----
module.exports = mongoose.model('Post', PostSchema);

================
File: src/server/models/Subscription.js
================
const SubscriptionSchema = new mongoose.Schema({
⋮----
enum: Object.values(subscriptionTiers),
⋮----
enum: Object.values(subscriptionStatus),
⋮----
enum: Object.values(paymentStatus),
⋮----
SubscriptionSchema.index(
⋮----
SubscriptionSchema.index({ nextBillingDate: 1 });
SubscriptionSchema.virtual('durationInDays').get(function() {
⋮----
const diffTime = Math.abs(this.endDate - this.startDate);
return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
⋮----
(!this.endDate || this.endDate > new Date());
⋮----
return this.find({
⋮----
nextBillingDate: { $gt: new Date() }
}).populate('creator', 'username displayName profilePicture');
⋮----
.populate('subscriber', 'username displayName profilePicture')
.sort({ createdAt: -1 })
.skip(skip)
.limit(limit);
⋮----
SubscriptionSchema.pre('save', function(next) {
⋮----
const nextDate = new Date();
nextDate.setMonth(nextDate.getMonth() + 1);
⋮----
if (this.isModified('status') && this.status === subscriptionStatus.CANCELLED && !this.endDate) {
this.endDate = new Date();
⋮----
next();
⋮----
const Subscription = mongoose.model('Subscription', SubscriptionSchema);

================
File: src/server/models/User.js
================
const UserSchema = new mongoose.Schema({
⋮----
// Virtual for profile data
UserSchema.virtual('profile', {
⋮----
UserSchema.index({ email: 1 }, { unique: true });
UserSchema.index({ username: 1 }, { unique: true });
UserSchema.index({ googleId: 1 }, { sparse: true });
UserSchema.pre('save', async function(next) {
if (!this.isModified('password')) return next();
⋮----
if (this.password && !this.password.startsWith('$2a$')) {
const salt = await bcrypt.genSalt(10);
this.password = await bcrypt.hash(this.password, salt);
⋮----
next();
⋮----
next(error);
⋮----
console.log('No password set for user');
⋮----
console.log('Comparing passwords...');
console.log('Candidate password length:', candidatePassword.length);
console.log('Stored hash length:', this.password.length);
console.log('Stored hash starts with:', this.password.substring(0, 10));
const isMatch = await bcrypt.compare(candidatePassword, this.password);
console.log('Password comparison result:', isMatch);
⋮----
const trimmedPassword = candidatePassword.trim();
⋮----
console.log('Trying with trimmed password...');
return await bcrypt.compare(trimmedPassword, this.password);
⋮----
console.error('Error comparing passwords:', error);
⋮----
const user = this.toObject();
⋮----
let user = await this.findOne({ [`${provider}Id`]: id });
⋮----
user = await this.findOne({ email });
⋮----
await user.save();
⋮----
user = await this.create({
⋮----
username: email.split('@')[0].toLowerCase() + Math.floor(Math.random() * 1000),
⋮----
const User = mongoose.model('User', UserSchema);

================
File: src/server/models/UserProfile.js
================
const socialLinksSchema = new mongoose.Schema({
⋮----
// Add other social platforms as needed
⋮----
const userStatsSchema = new mongoose.Schema({
⋮----
// Add other stats as needed
⋮----
const preferencesSchema = new mongoose.Schema({
⋮----
const UserProfileSchema = new mongoose.Schema({
⋮----
default: () => ({})
⋮----
default: () => ({
⋮----
UserProfileSchema.index({ user: 1 });
UserProfileSchema.index({ 'socialLinks.website': 1 });
UserProfileSchema.index({ isCreator: 1 });
UserProfileSchema.virtual('url').get(function() {
⋮----
return this.findOneAndUpdate(
⋮----
const profile = this.toObject();
⋮----
const UserProfile = mongoose.model('UserProfile', UserProfileSchema);

================
File: src/server/requests/new_user_request.rest
================
### Register a New User
### Base URL
@baseUrl=http://localhost:8080/api

### Register a New User
POST {{baseUrl}}/register
Content-Type: application/json

{
  "username": "testuser",
  "email": "testuser@example.com",
  "password": "password123"
}

### Log In with the New User
### Log In with the New User
POST {{baseUrl}}/login
Content-Type: application/json

{
  "email": "testuser@example.com",
  "password": "password123"
}

### Access a Protected Route
### Access a Protected Route
GET {{baseUrl}}/me
Authorization: Bearer your.jwt.token

================
File: src/server/routes/auth.js
================
require('dotenv').config();
const router = express.Router();
router.post('/signup', [
body('username')
.trim()
.isLength({ min: 3, max: 20 })
.withMessage('Username must be between 3 and 20 characters'),
body('email')
.isEmail()
.withMessage('Invalid email format'),
body('password')
.isLength({ min: 8 })
.withMessage('Password must be at least 8 characters long')
.matches(/[A-Z]/)
.withMessage('Password must contain at least one capital letter')
.matches(/[0-9]/)
.withMessage('Password must contain at least one number')
⋮----
logger.info(`Executing route: POST /api/signup`);
logger.info(`Received registration request body: ${JSON.stringify(req.body)}`);
const errors = validationResult(req);
if (!errors.isEmpty()) {
logger.warn(`Validation errors in registration: ${JSON.stringify(errors.array())}`);
return res.status(400).json({ errors: errors.array() });
⋮----
logger.info('Signup validation successful');
⋮----
logger.info(`Checking if email already exists: ${email}`);
⋮----
const emailExists = await User.findOne({ email });
⋮----
logger.warn(`Attempt to register with existing email: ${email}`);
return res.status(409).json({ message: 'Email already exists' });
⋮----
logger.info('Email available');
logger.info(`Checking if username already exists: ${username}`);
const userExists = await User.findOne({ username });
⋮----
logger.warn(`Attempt to register with existing username: ${username}`);
return res.status(409).json({ message: 'Username already exists' });
⋮----
logger.info('Username available');
logger.info('Creating new user instance');
const newUser = new User({
⋮----
logger.info(`Attempting to save new user to DB: ${newUser.username}`);
await newUser.save();
logger.info(`User registered successfully and saved to DB: ${newUser.username}`);
const newUserResponse = newUser.toObject();
⋮----
logger.info(`Sending success response for signup: ${JSON.stringify(newUserResponse)}`);
res.status(201).json({ newUser: newUserResponse });
⋮----
logger.error(`Error during signup process for email ${email}: ${err.message}`);
⋮----
return res.status(500).json({ message: 'Duplicate key error' });
⋮----
next(err);
⋮----
router.get('/me', auth(), async (req, res) => {
logger.info(`Executing route: GET /api/me`);
⋮----
logger.warn('GET /me: User not authenticated after middleware');
return res.status(401).json({ message: 'User not authenticated' });
⋮----
logger.info(`Fetching profile for user ID: ${req.user.userId}`);
⋮----
const user = await User.findById(req.user.userId).select('-password');
⋮----
logger.warn(`GET /me: User not found in DB for ID: ${req.user.userId}`);
return res.status(404).json({ message: 'User not found' });
⋮----
logger.info(`Successfully fetched profile for user: ${user.username}`);
res.json(user);
⋮----
logger.error(`Error fetching user profile for ID ${req.user.userId}: ${err.message}`);
⋮----
router.post('/login', [
body('usernameOrEmail').custom(value => {
⋮----
throw new Error('Username or email is required');
⋮----
.isLength({ min: 5 })
.withMessage('Password must be at least 5 characters long')
⋮----
logger.info(`Executing route: POST /api/login`);
logger.info(`Received login request body: ${JSON.stringify(req.body)}`);
⋮----
logger.warn(`Validation errors in login: ${JSON.stringify(errors.array())}`);
⋮----
logger.info('Login validation successful');
⋮----
logger.info(`Attempting to find user by username or email: ${usernameOrEmail}`);
⋮----
const user = await User.findOne({
⋮----
}).select('+password');
⋮----
logger.warn(`Login attempt with invalid username or email: ${usernameOrEmail}`);
return res.status(401).json({ message: 'Invalid credentials' });
⋮----
logger.info(`User found: ${user.username}`);
⋮----
logger.warn(`User ${user.username} has no password set`);
⋮----
logger.info(`Comparing password for user: ${user.username}`);
⋮----
hashStartsWith: user.password ? user.password.substring(0, 10) : 'null',
⋮----
isBcryptHash: user.password && user.password.startsWith('$2a$'),
passwordChars: Array.from(password).map(c => c.charCodeAt(0)),
passwordRaw: password.split('').map(c => `${c} (${c.charCodeAt(0)})`).join(' ')
⋮----
logger.debug('Password comparison details:', comparisonDetails);
// Try direct comparison first for debugging
⋮----
logger.debug('Direct password match!');
⋮----
logger.debug('No direct password match');
⋮----
const isMatch = await bcrypt.compare(password, user.password);
logger.debug('Bcrypt comparison result:', { isMatch });
⋮----
logger.warn(`Login attempt with invalid password for user: ${user.username}`);
⋮----
logger.info('Password comparison successful');
logger.info(`Generating JWT token for user: ${user.username}`);
⋮----
const token = jwt.sign(
⋮----
logger.info(`JWT token generated with expiration: ${expiresIn}`);
const userResponse = user.toObject();
⋮----
logger.info(`Sending success response for login: ${JSON.stringify({ user: userResponse, token: '[REDACTED]' })}`);
return res.status(200).json({
⋮----
logger.error(`Error during login process for username or email ${usernameOrEmail}: ${err.message}`);

================
File: src/server/routes/content.js
================
const router = express.Router();
router.post('/upload', authMiddleware(['creator']), async (req, res) => {
logger.info(`Route /upload POST called`);
⋮----
const newContent = new Content({
⋮----
await newContent.save();
res.status(201).json(newContent);
⋮----
logger.error(`Content upload error: ${error.message}`);
⋮----
return res.status(409).json({ message: "Content already exists." });
⋮----
res.status(500).json({ message: 'Failed to upload content' });
⋮----
router.get('/', async (req, res) => {
logger.info(`Route / GET called`);
⋮----
const contents = await Content.find().populate('creator');
res.status(200).json(contents);
⋮----
logger.error(`Content fetch error: ${error.message}`);
res.status(500).json({ message: 'Failed to fetch contents' });
⋮----
router.post('/', authMiddleware(['creator']), async (req, res) => {
logger.info(`Route / POST called`);
⋮----
const content = new Content({
⋮----
await content.save();
logger.info(`Content created: ${content._id}`);
res.status(201).json(content);
⋮----
logger.error(`Content creation error: ${error.message}`);
⋮----
res.status(400).json({ message: err.message });
⋮----
logger.info(`Route / with filters GET called`);
⋮----
const contents = await Content.find(filter)
.populate('creator', 'username name')
.sort('-createdAt');
res.json(contents);
⋮----
res.status(500).json({ message: err.message });
⋮----
router.get('/:id', async (req, res) => {
logger.info(`Route /:id GET called`);
⋮----
const content = await Content.findById(req.params.id)
.populate('creator', 'username name');
⋮----
return res.status(404).json({ message: 'Content not found' });
⋮----
res.json(content);
⋮----
res.status(500).json({ message: error.message });
⋮----
router.put('/:id', authMiddleware(['creator']), async (req, res) => {
logger.info(`Route /:id PUT called`);
⋮----
const content = await Content.findOne({
⋮----
Object.assign(content, req.body);
⋮----
logger.info(`Content updated: ${content._id}`);
⋮----
logger.error(`Content update error: ${error.message}`);
⋮----
res.status(500).json({ message: 'Failed to update content' });
⋮----
router.delete('/:id', authMiddleware(['creator']), async (req, res) => {
logger.info(`Route /:id DELETE called`);
⋮----
const content = await Content.findOneAndDelete({
⋮----
logger.info(`Content deleted: ${req.params.id}`);
res.json({ message: 'Content deleted' });
⋮----
logger.error(`Content deletion error: ${error.message}`);
res.status(500).json({ message: 'Failed to delete content' });

================
File: src/server/routes/contentRoutes.js
================
const router = express.Router();
⋮----
mongoose.connection.once('open', () => {
gfs = Grid(mongoose.connection.db, mongoose.mongo);
gfs.collection('uploads');
⋮----
router.post('/upload', upload.fields([{ name: 'media', maxCount: 1 }, { name: 'thumbnail', maxCount: 1 }]), async (req, res, next) => {
⋮----
errors.push('Title is required and must be a string');
⋮----
errors.push('Media Type is required and must be a string');
⋮----
errors.push('Description must be a string');
⋮----
errors.push('Creator must be a string');
⋮----
errors.push('Is Exclusive must be a boolean');
⋮----
errors.push('Required Level must be a number');
⋮----
return res.status(400).json({ errors });
⋮----
errors.push('Media file is required');
⋮----
errors.push('Thumbnail file is required');
⋮----
const newContent = new Content({
⋮----
await newContent.save();
return res.status(201).json(newContent);
⋮----
return res.status(409).json({ message: 'Content already exists' });
⋮----
next(error);
⋮----
router.get('/', async (req, res, next) => {
⋮----
const contents = await Content.find().populate('creator').exec();
⋮----
return res.status(404).json({ message: 'Contents not found' });
⋮----
return res.status(200).json(contents);
⋮----
res.status(500).json({ error: 'Failed to fetch contents' });
⋮----
router.get('/files/:filename', (req, res) => {
gfs.files.findOne({ filename: req.params.filename }, (err, file) => {
⋮----
return res.status(404).json({ message: 'No file exists' });
⋮----
logger.error(err);
return res.status(500).json({ message: 'Error finding file' });
⋮----
if (file.contentType.includes('image') || file.contentType.includes('video')) {
const readStream = gfs.createReadStream(file.filename);
readStream.pipe(res);
⋮----
return res.status(400).json({ message: 'Not an image or video' });

================
File: src/server/routes/featuredProfiles.js
================
const router = express.Router();
⋮----
router.get('/', async (req, res) => {
⋮----
const featuredProfiles = await featuredProfileService.getFeaturedProfiles();
res.json(featuredProfiles);
⋮----
res.status(500).json({ message: 'Error fetching featured profiles' });
⋮----
router.post('/', async (req, res) => {
⋮----
return res.status(400).json({ message: 'Missing required fields' });
⋮----
const featuredProfile = await featuredProfileService.addFeaturedProfile(userId, displayOrder);
res.status(201).json(featuredProfile);
⋮----
res.status(500).json({ message: 'Error adding featured profile' });
⋮----
router.put('/:userId/order', async (req, res) => {
⋮----
return res.status(400).json({ message: 'Missing displayOrder' });
⋮----
const featuredProfile = await featuredProfileService.updateFeaturedProfile(req.params.userId, displayOrder);
res.json(featuredProfile);
⋮----
res.status(500).json({ message: 'Error updating featured profile' });
⋮----
router.put('/:userId/status', async (req, res) => {
⋮----
return res.status(400).json({ message: 'Missing isActive' });
⋮----
const featuredProfile = await featuredProfileService.updateFeaturedProfileStatus(req.params.userId, isActive);
⋮----
res.status(500).json({ message: 'Error updating featured profile status' });

================
File: src/server/routes/post.js
================
const router = express.Router();
⋮----
router.get('/:username', postController.getUserPosts);

================
File: src/server/routes/profiles.js
================
const router = express.Router();
⋮----
router.get('/featured', asyncHandler(async (req, res) => {
⋮----
const featuredProfiles = await profileService.getFeaturedProfiles();
res.json({ profiles: featuredProfiles });
⋮----
res.status(500).json({

================
File: src/server/routes/subscriptions.js
================
const router = express.Router();
router.post('/', auth(), async (req, res) => {
logger.info('POST /api/subscriptions route handler executed');
⋮----
const subscription = new Subscription({
⋮----
endDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
⋮----
await subscription.save();
logger.info(`Subscription created: ${subscription._id}`);
res.status(201).json(subscription);
⋮----
logger.error(`Subscription creation error: ${err.message}`);
⋮----
return res.status(400).json({ message: err.message });
⋮----
return res.status(409).json({message: "Subscription already exists"})
⋮----
return res.status(500).json({ message: "Server Error" });
res.status(400).json({ message: err.message });
⋮----
router.get('/my', auth(), async (req, res) => {
logger.info('GET /api/subscriptions/my route handler executed');
⋮----
const subscriptions = await Subscription.find({
⋮----
}).populate('creator', 'username name');
res.json(subscriptions);
⋮----
logger.error(`Subscription fetch error: ${err.message}`);
⋮----
return res.status(400).json({ message: "Validation error" });
⋮----
res.status(500).json({ message: err.message });
⋮----
router.get('/subscribers', auth(['creator']), async (req, res) => {
logger.info('GET /api/subscriptions/subscribers route handler executed');
⋮----
}).populate('subscriber', 'username name');
⋮----
logger.error(`Subscribers fetch error: ${err.message}`);
⋮----
router.patch('/:id/cancel', auth(), async (req, res) => {
logger.info('PATCH /api/subscriptions/:id/cancel route handler executed');
⋮----
const subscription = await Subscription.findOne({
⋮----
return res.status(404).json({ message: 'Subscription not found' });
⋮----
logger.info(`Subscription cancelled: ${subscription._id}`);
res.json(subscription);
⋮----
logger.error(`Subscription cancellation error: ${err.message}`);

================
File: src/server/routes/upload.js
================
const router = express.Router();

================
File: src/server/routes/user.js
================
const router = express.Router();
⋮----
const upload = multer({
storage: multer.memoryStorage(),
⋮----
fileFilter: (req, file, cb) => {
⋮----
const fileExt = path.extname(file.originalname).toLowerCase();
⋮----
if (allowedTypes.includes(file.mimetype) || validExt.includes(fileExt)) {
cb(null, true);
⋮----
cb(new Error('Invalid file type. Only JPEG, JPG, PNG, and WebP images are allowed.'));
⋮----
router.get('/profile', (req, res) => {
⋮----
return res.status(401).json({
⋮----
res.redirect(`/api/users/${username}`);
⋮----
router.get('/:username', asyncHandler(userController.getUserProfile));
router.get('/:username/stats', asyncHandler(userController.getUserStats));
router.get('/:username/posts', asyncHandler(userController.getUserPosts));
router.post(
⋮----
auth(),
isOwner('username'),
upload.single('profilePicture'),
asyncHandler(async (req, res) => {
⋮----
return res.status(400).json({
⋮----
return await userController.uploadProfilePicture(req, res);
⋮----
logger.error('Profile picture upload error in route handler', {
⋮----
return res.status(500).json({
⋮----
router.patch(
⋮----
logger.error('Invalid username parameter', {
⋮----
if (!updates || Object.keys(updates).length === 0) {
logger.error('No updates provided', {
⋮----
const user = await User.findOneAndUpdate(
⋮----
).select('-password -googleId -__v -createdAt -updatedAt');
⋮----
logger.error('User not found for patch user', { username });
return res.status(404).json({
⋮----
logger.info('Profile updated successfully', {
⋮----
updatedFields: Object.keys(updates)
⋮----
res.status(200).json(user);
⋮----
logger.error('Profile update error', {

================
File: src/server/services/analytics.js
================
const getCreatorAnalytics = async (creatorId) => {
⋮----
] = await Promise.all([
Content.aggregate([
⋮----
Subscription.countDocuments({
⋮----
Subscription.aggregate([
⋮----
const getUserEngagement = async (userId) => {
⋮----
Content.find({ 'views.userId': userId }).count(),
Content.find({ 'likes.userId': userId }).count(),
Comment.find({ userId }).count(),
Subscription.find({ subscriber: userId, status: 'active' })

================
File: src/server/services/drm.js
================
const generateContentKey = () => {
return crypto.randomBytes(32).toString('hex');
⋮----
const encryptContent = (content, key) => {
const iv = crypto.randomBytes(16);
const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key, 'hex'), iv);
let encrypted = cipher.update(content);
encrypted = Buffer.concat([encrypted, cipher.final()]);
⋮----
iv: iv.toString('hex'),
encryptedContent: encrypted.toString('hex')
⋮----
const decryptContent = (encryptedData, key) => {
const decipher = crypto.createDecipheriv(
⋮----
Buffer.from(key, 'hex'),
Buffer.from(encryptedData.iv, 'hex')
⋮----
let decrypted = decipher.update(Buffer.from(encryptedData.encryptedContent, 'hex'));
decrypted = Buffer.concat([decrypted, decipher.final()]);
⋮----
const addWatermark = (content, userId) => {
⋮----
timestamp: new Date().toISOString()

================
File: src/server/services/featuredProfileService.js
================
const getFeaturedProfiles = async () => {
⋮----
logger.info('Fetching featured profiles from database...');
⋮----
.find({ isActive: true })
.sort({ displayOrder: 1, lastUpdated: -1 })
.limit(3)
.lean()
.catch(err => {
logger.error('Error fetching featured profiles:', err);
⋮----
logger.info(`Found ${featuredProfiles.length} featured profiles in database`);
logger.debug('Featured profiles raw data:', JSON.stringify(featuredProfiles, null, 2));
⋮----
logger.warn('No active featured profiles found in database');
⋮----
logger.debug('Featured profiles from DB:', JSON.stringify(featuredProfiles, null, 2));
⋮----
.map(profile => {
⋮----
logger.warn('Invalid profile data:', profile);
⋮----
.filter(Boolean)
.filter(userId => {
⋮----
new mongoose.Types.ObjectId(userId);
⋮----
logger.error(`Invalid userId format: ${userId}`, error);
⋮----
logger.info(`Extracted ${userIds.length} valid user IDs from featured profiles`);
⋮----
logger.error('No valid user IDs found in featured profiles');
⋮----
logger.error('Error processing user IDs:', error);
⋮----
users = await User.find({ _id: { $in: userIds } })
.select('username displayName profilePicture bio postsCount followersCount subscribersCount')
⋮----
logger.error('Error fetching user details:', err);
⋮----
logger.info(`Fetched ${users.length} user records for featured profiles`);
⋮----
logger.error('No user records found for featured profiles');
⋮----
logger.error('Error in user details fetch:', error);
⋮----
const userMap = users.reduce((acc, user) => {
acc[user._id.toString()] = user;
⋮----
logger.warn(`No user found for featured profile with userId: ${profile.userId}`);
⋮----
.filter(Boolean);
logger.info(`Mapped ${mappedProfiles.length} featured profiles with user data`);
⋮----
logger.error('CRITICAL ERROR in getFeaturedProfiles:', {
⋮----
const addFeaturedProfile = async (userId, displayOrder) => {
⋮----
const featuredProfile = new FeaturedProfile({
⋮----
await featuredProfile.save();
⋮----
logger.error('Error adding featured profile:', error);
⋮----
const updateFeaturedProfile = async (userId, displayOrder) => {
⋮----
const featuredProfile = await FeaturedProfile.findOne({ userId });
⋮----
throw new Error('Featured profile not found');
⋮----
logger.error('Error updating featured profile:', error);
⋮----
const updateFeaturedProfileStatus = async (userId, isActive) => {
⋮----
logger.error('Error updating featured profile status:', error);

================
File: src/server/services/search.js
================
const searchContent = async (query, filters = {}) => {
⋮----
const contents = await Content.find(searchQuery)
.populate('creator', 'username name avatarUrl')
.sort('-createdAt');
⋮----
const getRecommendations = async (userId) => {
const userHistory = await Content.find({
⋮----
}).select('category tags creator');
const categories = [...new Set(userHistory.map(c => c.category))];
const tags = [...new Set(userHistory.flatMap(c => c.tags))];
const creators = [...new Set(userHistory.map(c => c.creator))];
const recommendations = await Content.find({
⋮----
.sort('-views.length')
.limit(10);

================
File: src/server/services/StorageService.js
================
storage = new Storage({
⋮----
bucket = storage.bucket(bucketName);
logger.info('Google Cloud Storage initialized with bucket:', { bucket: bucketName });
⋮----
logger.error('Failed to initialize Google Cloud Storage:', error);
throw new Error('Failed to initialize Google Cloud Storage');
⋮----
const uploadDir = path.join(process.cwd(), 'uploads');
if (!fs.existsSync(uploadDir)) {
fs.mkdirSync(uploadDir, { recursive: true });
⋮----
logger.info('Using local file storage in directory: uploads/');
⋮----
class StorageService {
⋮----
throw new Error('Google Cloud Storage bucket is not initialized');
⋮----
this.uploadDir = path.resolve(process.env.LOCAL_UPLOAD_DIR || path.join(process.cwd(), 'public', 'uploads'));
if (!fs.existsSync(this.uploadDir)) {
fs.mkdirSync(this.uploadDir, { recursive: true });
logger.info(`Created upload directory: ${this.uploadDir}`);
⋮----
static getInstance() {
⋮----
this.instance = new StorageService();
⋮----
async uploadFile(username, file) {
⋮----
logger.error('Invalid file object received', {
⋮----
fileProperties: Object.keys(file || {})
⋮----
logger.info('Starting upload validation', {
⋮----
fileName = `${username}-${uuidv4()}${path.extname(file.originalname)}`;
if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
logger.error('Invalid file type', {
⋮----
logger.error('File size exceeds limit', {
⋮----
logger.info('Starting file upload to GCS', { username, fileName });
const blob = this.bucket.file(fileName);
const blobStream = blob.createWriteStream({
⋮----
uploadedAt: new Date().toISOString()
⋮----
await new Promise((resolve, reject) => {
blobStream.on('error', (error) => {
logger.error('Stream error during file upload', {
⋮----
reject(new Error('Failed to upload file to storage'));
⋮----
blobStream.on('finish', async () => {
⋮----
await blob.makePublic();
logger.info('File upload completed successfully', {
⋮----
resolve();
⋮----
logger.error('Failed to make file public', {
⋮----
reject(error);
⋮----
blobStream.end(file.buffer);
⋮----
const filePath = path.join(this.uploadDir, fileName);
await fs.promises.writeFile(filePath, file.buffer);
⋮----
logger.info('File saved to local storage', {
⋮----
logger.info('File upload completed', {
⋮----
logger.error('Upload failed', {
⋮----
await this.bucket.file(fileName).delete();
logger.info('Partial file cleaned up from GCS', { fileName });
⋮----
if (fs.existsSync(filePath)) {
await fs.promises.unlink(filePath);
logger.info('Partial file cleaned up from local storage', { fileName });
⋮----
logger.error('Failed to clean up partial file', {
⋮----
async deleteFile(filename) {
⋮----
logger.error('No filename provided for deletion');
⋮----
await this.bucket.file(filename).delete();
logger.info('File deleted successfully from GCS', { filename });
⋮----
const filePath = path.join(this.uploadDir, filename);
⋮----
logger.info('File deleted successfully from local storage', { filename });
⋮----
logger.warn('File not found for deletion', { filename });
⋮----
logger.error(`Failed to delete file from ${storageType}`, {
⋮----
const storageService = StorageService.getInstance();
⋮----
uploadFile: storageService.uploadFile.bind(storageService),
deleteFile: storageService.deleteFile.bind(storageService)

================
File: src/server/checkFeaturedProfiles.js
================
dotenv.config({ path: path.join(__dirname, '../../.env') });
⋮----
async function checkFeaturedProfiles() {
⋮----
await mongoose.connect(process.env.MONGODB_URI);
console.log('Connected to MongoDB');
const featuredProfiles = await FeaturedProfile.find({ isActive: true })
.sort({ displayOrder: 1 })
.lean();
console.log(`Found ${featuredProfiles.length} featured profiles`);
⋮----
console.log('\nFeatured Profiles:');
console.log('----------------');
⋮----
const user = await User.findById(profile.userId);
console.log(`- User ID: ${profile.userId}`);
console.log(`  Display Order: ${profile.displayOrder}`);
console.log(`  Username: ${user?.username || 'Not found'}`);
console.log(`  Display Name: ${user?.displayName || 'Not found'}`);
console.log(`  Profile Picture: ${user?.profilePicture || 'Not found'}`);
console.log('---');
⋮----
console.log('No featured profiles found');
⋮----
process.exit(0);
⋮----
console.error('Error checking featured profiles:', error);
process.exit(1);
⋮----
checkFeaturedProfiles();

================
File: src/server/devLogin.js
================
const devLogin = (req, res, next) => {
if (req.header('Authorization') === 'Basic ZGVtbzpkZW1v') {
⋮----
next();

================
File: src/server/Dockerfile
================
# Use an official Node.js runtime as the base image
FROM node:20.18.1

# Set the working directory
WORKDIR /app

# Copy package.json and package-lock.json (if using) to the working directory
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the backend code to the working directory
COPY . .

# Expose the port your backend server is listening on (likely 8080 based on your server.js)
EXPOSE 8080

# Define the command to run your application
CMD [ "node", "server.js" ]

================
File: src/server/package.json
================
{
  "name": "server",
  "version": "1.0.0",
  "main": "src/server/server.js",
  "scripts": {
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "engines": {
    "node": "20.18.1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@aws-sdk/client-s3": "^3.525.0",
    "@aws-sdk/s3-request-presigner": "^3.682.0",
    "@google-cloud/storage": "^7.16.0",
    "aws-sdk": "^2.1691.0",
    "axios": "^1.9.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.1",
    "express-async-handler": "^1.2.0",
    "express-rate-limit": "^7.2.0",
    "express-validator": "^7.2.1",
    "gridfs-stream": "^1.1.1",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.2.0",
    "morgan": "^1.10.0",
    "multer": "^1.4.4",
    "multer-gridfs-storage": "^5.0.2",
    "multer-s3": "^3.0.1",
    "nodemailer": "^6.9.11",
    "socket.io": "^4.7.4",
    "stripe": "^14.19.0",
    "uuid": "^11.1.0",
    "winston": "^3.11.0",
    "xss": "^1.0.14"
  }
}

================
File: src/server/seedTestData.js
================
const envPath = path.join(__dirname, '../../.env');
dotenv.config({ path: envPath });
console.log('Environment file path:', envPath);
console.log('MONGODB_URI:', process.env.MONGODB_URI ? '***' : 'Not found');
⋮----
async function seedDatabase() {
⋮----
await mongoose.connect(process.env.MONGODB_URI);
console.log('Connected to MongoDB');
await User.deleteMany({});
await FeaturedProfile.deleteMany({});
console.log('Cleared existing data');
⋮----
const hashedPassword = await bcrypt.hash(user.password, 10);
const newUser = new User({
⋮----
await newUser.save();
createdUsers.push(newUser);
console.log(`Created user: ${user.username}`);
⋮----
const featuredUsers = createdUsers.slice(0, 2);
⋮----
const featuredProfile = new FeaturedProfile({
⋮----
await featuredProfile.save();
console.log(`Featured user: ${user.username}`);
⋮----
console.log('Database seeded successfully!');
process.exit(0);
⋮----
console.error('Error seeding database:', error);
process.exit(1);
⋮----
seedDatabase();

================
File: src/server/server.js
================
require('dotenv').config({ path: '../../.env' });
⋮----
const app = express();
app.use((req, res, next) => {
logger.info(`Incoming Request: ${req.method} ${req.url}`);
next();
⋮----
app.use(cors());
app.use(express.json());
app.use(devLogin);
app.use(requestLogger);
app.use(morgan('dev'));
const uploadsDir = path.resolve(process.env.LOCAL_UPLOAD_DIR || path.join(process.cwd(), 'public', 'uploads'));
app.use('/uploads', express.static(uploadsDir));
logger.info(`Serving static files from: ${uploadsDir}`);
⋮----
const start = Date.now();
res.on('finish', () => {
const duration = Date.now() - start;
logger.info({
⋮----
const distPath = path.join(__dirname, 'dist');
app.use(express.static(distPath));
app.get('/health', (req, res) => {
logger.info('Health check hit');
res.json({
⋮----
timestamp: new Date().toISOString(),
⋮----
app.use('/api', (req, res, next) => {
logger.info(`API Hit: ${req.method} ${req.url}`);
logger.debug('Headers:', req.headers);
logger.debug('Body:', req.body);
req.setTimeout(51730, () => {
logger.warn(`Request timeout: ${req.method} ${req.url}`);
⋮----
app.use('/api/auth', authRoutes);
app.use('/api/content', contentRoutes);
app.use('/api/subscriptions', subscriptionRoutes);
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);
app.use('/api/profiles', profilesRoutes);
app.use('/api/featured', featuredProfilesRoutes);
app.use(errorHandler);
app.get('*', (req, res, next) => {
if (!req.url.startsWith('/api')) {
res.sendFile(path.join(distPath, 'index.html'));
⋮----
process.on('uncaughtException', (err) => {
logger.error('UNCAUGHT EXCEPTION', {
⋮----
process.exit(1);
⋮----
process.on('unhandledRejection', (reason, promise) => {
logger.error('UNHANDLED PROMISE REJECTION', {
⋮----
const startServer = async () => {
logger.info('Initializing server...');
⋮----
await connectDB();
logger.info('Database connected');
app.listen(PORT, '0.0.0.0', () => {
logger.info(`Server running on port ${PORT}`);
⋮----
logger.error('Startup Error', err);
⋮----
startServer();

================
File: src/services/apiService.ts
================
import axios from 'axios';
import { API_BASE_URL } from '../config';
⋮----
export interface LoginData {
  usernameOrEmail: string;
  password: string;
}
export interface SignupData {
  username: string;
  password: string;
  email: string;
  isCreator: boolean;
}
export const loginUser = (data: LoginData) =>
export const signupUser = (data: SignupData) =>
export const getProfile = (userId: string) =>
export const getProfileByUsername = (username: string) =>
export const updateUserProfile = (userId: string, data: any) =>
export const updateUserSettings = (userId: string, settings: any) =>
export const uploadProfilePicture = (username: string, file: File) =>
export const uploadCoverPhoto = (userId: string, file: File) =>
export const followUser = (targetUserId: string) =>
export const unfollowUser = (targetUserId: string) =>
export const getUserStats = (userId: string) =>
export const searchUsers = (query: string, page = 1, limit = 20) =>
export const requestVerification = (userId: string) =>

================
File: src/services/profileService.ts
================
import { logger } from '../utils/logger';
import {
  getProfile as apiGetProfile,
  getProfileByUsername as apiGetProfileByUsername,
  updateUserProfile as apiUpdateUserProfile,
  updateUserSettings as apiUpdateUserSettings,
  uploadProfilePicture as apiUploadProfilePicture,
  uploadCoverPhoto as apiUploadCoverPhoto,
  followUser as apiFollowUser,
  unfollowUser as apiUnfollowUser,
  getUserStats as apiGetUserStats,
  searchUsers as apiSearchUsers
} from './apiService';
import type {
  UserProfile,
  UserStats,
  ProfileInput,
  UserSettingsUpdate,
  FeaturedProfileConfig,
  ApiResponse
} from '../types/user';
⋮----
class ProfileService
⋮----
private constructor()
public static getInstance(): ProfileService
private async ensureProfilesDirectory(): Promise<void>
public async getProfile(userId: string): Promise<UserProfile | null>
public async getProfileByUsername(username: string): Promise<UserProfile | null>
public async updateProfile(
    userId: string,
    updates: ProfileInput
): Promise<UserProfile>
public async getCurrentUser(): Promise<ApiResponse<UserProfile>>
public async getUserProfile(usernameOrId: string): Promise<ApiResponse<UserProfile>>
public async updateUserProfile(
    userId: string,
    profileData: ProfileInput
): Promise<ApiResponse<UserProfile>>
public async updateUserSettings(
    userId: string,
    settings: UserSettingsUpdate
): Promise<ApiResponse<UserProfile>>
public async uploadProfilePicture(
    username: string,
    file: File
): Promise<ApiResponse<
public async uploadCoverPhoto(
    userId: string,
    file: File
): Promise<ApiResponse<
public async followUser(_userId: string, targetUserId: string): Promise<ApiResponse<
public async unfollowUser(_userId: string, targetUserId: string): Promise<ApiResponse<
public async requestVerification(userId: string): Promise<ApiResponse<
public async getUserStats(userId: string): Promise<ApiResponse<UserStats>>
public async searchUsers(
    query: string,
    page = 1,
    limit = 20
): Promise<ApiResponse<
public async getFeaturedProfiles(): Promise<ApiResponse<

================
File: src/services/userProfileService.ts
================
import { logger } from '../utils/logger';
import { UserProfile, FeaturedProfileConfig, EditableProfileFields } from '../types/user';
import { getProfile, getProfileByUsername, updateProfile, uploadProfilePicture } from '../services/apiService';
import fs from 'fs/promises';
import path from 'path';
export class UserProfileService
⋮----
private constructor()
public static getInstance(): UserProfileService
private async ensureProfilesDirectory(): Promise<void>
public async getProfileByUsername(username: string): Promise<UserProfile | null>
public async getProfile(userId: string): Promise<UserProfile | null>
public async getFeaturedProfiles(): Promise<FeaturedProfileConfig[]>
public async updateProfile(userId: string, updates: EditableProfileFields): Promise<boolean>
public async updateProfilePicture(userId: string, file: File): Promise<string | null>
private isValidEmail(email: string): boolean

================
File: src/theme/components/ThemeProvider.tsx
================
import React, { useEffect, useMemo, useCallback, useState, useRef } from 'react';
import { ThemeProvider as MuiThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { ThemeContext } from '../context/ThemeContext';
import { themeManager } from '../managers/ThemeManager';
import { lightTheme } from '../themes/light';
import { darkTheme } from '../themes/dark';
import type { ThemeOptions } from '../types';
interface ThemeProviderProps {
  children: React.ReactNode;
  onError?: (error: Error) => void;
}
export const ThemeProvider: React.FC<ThemeProviderProps> = ({
  children,
  onError = (error) => console.error('Theme Error:', error)
}) =>
⋮----
const toggleTheme = () =>
const setTheme = (newTheme: 'light' | 'dark') =>
const getTheme = ()
const getEffectiveTheme = ()

================
File: src/theme/context/ThemeContext.ts
================
import { createContext } from 'react';
import { ThemeContextType } from '../types';

================
File: src/theme/hooks/useTheme.ts
================
import { useContext } from 'react';
import { ThemeContext } from '../context/ThemeContext';
export const useTheme = () =>

================
File: src/theme/managers/ThemeManager.ts
================
import type { ThemeOptions } from '../types';
type ColorVariant = {
  main: string;
  light: string;
  dark: string;
  contrastText: string;
};
type ThemePalette = {
  mode: 'light' | 'dark';
  primary: ColorVariant;
  secondary: ColorVariant;
  error: { main: string };
  warning: { main: string };
  info: { main: string };
  success: { main: string };
  background: {
    default: string;
    paper: string;
  };
  text: {
    primary: string;
    secondary: string;
    disabled: string;
  };
  divider: string;
  action: {
    active: string;
    hover: string;
    selected: string;
    disabled: string;
    disabledBackground: string;
  };
};
type CompletePaletteOptions = Omit<ThemePalette, 'error' | 'warning' | 'info' | 'success' | 'action'> & {
  error: ColorVariant;
  warning: ColorVariant;
  info: ColorVariant;
  success: ColorVariant;
};
import { lightPalette } from '../themes/light';
import { darkPalette } from '../themes/dark';
class ThemeManager
⋮----
private static log(...args: unknown[]): void
private constructor()
private initialize(): void
private applyTheme(): void
⋮----
const onTransitionEnd = () =>
⋮----
public static getInstance(): ThemeManager
public getTheme(): 'light' | 'dark'
public getEffectiveTheme(): 'light' | 'dark'
public setTheme(theme: 'light' | 'dark'): void
public toggleTheme(): void
public getThemeOptions(): ThemeOptions
public subscribe(callback: (theme: 'light' | 'dark') => void): () => void
public cleanup(): void
private notifySubscribers(): void
private isValidTheme(theme: string): boolean

================
File: src/theme/themes/base.ts
================
import { ThemeOptions } from '@mui/material/styles';

================
File: src/theme/themes/dark.ts
================
import { createTheme } from '@mui/material/styles';
import { baseTheme } from './base';

================
File: src/theme/themes/index.ts
================


================
File: src/theme/themes/light.ts
================
import { createTheme } from '@mui/material/styles';
import { baseTheme } from './base';

================
File: src/theme/types/index.ts
================
export type ThemeMode = 'light' | 'dark' | 'system';
export interface PaletteOptions {
  mode?: 'light' | 'dark';
  primary: {
    main: string;
    light: string;
    dark: string;
    contrastText: string;
  };
  secondary: {
    main: string;
    light: string;
    dark: string;
    contrastText: string;
  };
  error: {
    main: string;
    light: string;
    dark: string;
    contrastText?: string;
  };
  warning: {
    main: string;
    light?: string;
    dark?: string;
    contrastText?: string;
  };
  info: {
    main: string;
    light?: string;
    dark?: string;
    contrastText?: string;
  };
  success: {
    main: string;
    light?: string;
    dark?: string;
    contrastText?: string;
  };
  background: {
    default: string;
    paper: string;
  };
  text: {
    primary: string;
    secondary: string;
    disabled: string;
  };
  divider: string;
  action?: {
    active?: string;
    hover?: string;
    selected?: string;
    disabled?: string;
    disabledBackground?: string;
  };
}
export interface ThemeOptions {
  palette: PaletteOptions;
  components?: {
    [key: string]: any;
  };
  typography?: {
    fontFamily?: string;
    [key: string]: any;
  };
  spacing: (factor: number) => string;
  shape?: {
    borderRadius: number;
  };
}
export interface ThemeContextType {
  theme: ThemeMode;
  isDark: boolean;
  toggleTheme: () => void;
  setTheme: (theme: ThemeMode) => void;
  themeOptions: ThemeOptions;
}
export const isThemeMode = (value: unknown): value is ThemeMode =>

================
File: src/theme/index.ts
================


================
File: src/theme/README.md
================
# Theme Module

This module provides a robust theming solution for SushFlix, built on Material-UI's theming system with first-class TypeScript support. It offers:

- 🎨 Light and dark theme variants
- 🌓 Automatic system preference detection
- 🛠 Type-safe theme customization
- ⚡ Optimized performance with memoization
- 📱 Responsive design support

## Structure

```
src/theme/
├── components/           # Theme-related React components
│   └── ThemeProvider.tsx  # Theme provider component
├── context/               # Theme context
│   └── ThemeContext.ts
├── hooks/                 # Theme-related hooks
│   └── useTheme.ts
├── managers/             # Theme management logic
│   └── ThemeManager.ts
├── themes/               # Theme definitions
│   ├── base.ts           # Base theme configuration
│   ├── dark.ts           # Dark theme
│   ├── index.ts          # Theme exports
│   └── light.ts          # Light theme
├── types/                # TypeScript type definitions
│   └── index.ts
├── README.md             # This file
└── index.ts              # Public API
```

## Usage

### ThemeProvider

Wrap your application with the `ThemeProvider`:

```tsx
import { ThemeProvider } from './theme';

function App() {
  return (
    <ThemeProvider>
      {/* Your app */}
    </ThemeProvider>
  );
}
```

### useTheme Hook

Access the theme context in your components:

```tsx
import { useTheme } from '../theme';

function MyComponent() {
  const { theme, isDark, toggleTheme } = useTheme();
  
  return (
    <div>
      <button onClick={toggleTheme}>
        Switch to {isDark ? 'Light' : 'Dark'} Mode
      </button>
      <p>Current theme: {theme}</p>
    </div>
  );
}
```

## Theming

### Theme Modes

- `light`: Light theme
- `dark`: Dark theme
- `system`: Follows system preference

### Customization

1. **Colors**: Update the palette in `themes/light.ts` or `themes/dark.ts`
2. **Typography**: Modify the base theme in `themes/base.ts`
3. **Components**: Override component styles in the respective theme files

## Best Practices

### Theme Tokens
Always use theme tokens instead of hardcoded values:

```typescript
// Good
const StyledDiv = styled('div')(({ theme }) => ({
  backgroundColor: theme.palette.background.default,
  color: theme.palette.text.primary,
}));

// Bad
const StyledDiv = styled('div')({
  backgroundColor: '#ffffff',
  color: '#000000',
});
```

### Typography
- Use the theme's typography scale for consistent text styling
- Prefer `theme.typography` over direct CSS for text styles
- Use responsive typography utilities

### Dark Mode Support
- Test all components in both light and dark modes
- Use theme-aware colors (avoid hardcoded colors)
- Consider contrast ratios for accessibility

### Performance
- Memoize theme-dependent calculations with `useMemo`
- Avoid inline styles that depend on theme
- Use theme breakpoints for responsive design

### Type Safety
- Import types from `./types` when extending the theme
- Use TypeScript generics for theme-aware components
- Add proper type guards for theme validation

## Advanced Usage

### Extending the Theme

Add custom theme properties in `types/index.ts`:

```typescript
declare module '@mui/material/styles' {
  interface Theme {
    custom: {
      customProperty: string;
    };
  }
  interface ThemeOptions {
    custom?: {
      customProperty?: string;
    };
  }
}
```

### Server-Side Rendering

For SSR, ensure the theme is consistent between server and client:

```typescript
// In your server-side code
const theme = createTheme(light);
const html = renderToString(
  <CacheProvider value={cache}>
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>
  </CacheProvider>
);
```

## Testing

When testing components that use the theme, wrap them in a `ThemeProvider`:

```tsx
test('should render with theme', () => {
  const { container } = render(
    <ThemeProvider>
      <MyComponent />
    </ThemeProvider>
  );
  
  // Test theme-dependent styles
  expect(container.firstChild).toHaveStyle({
    backgroundColor: expect.any(String),
    color: expect.any(String),
  });
});

test('should toggle theme', () => {
  const { getByText, container } = render(
    <ThemeProvider>
      <MyToggleButton />
    </ThemeProvider>
  );
  
  const button = getByText(/dark/i);
  fireEvent.click(button);
  
  // Verify theme change
  expect(container.firstChild).toHaveStyle({
    backgroundColor: expect.any(String),
  });
});
```

================
File: src/theme/types.ts
================
export type ThemeMode = 'light' | 'dark';
export interface PaletteOptions {
  mode?: 'light' | 'dark';
  primary?: {
    main: string;
    light: string;
    dark: string;
    contrastText: string;
  };
  secondary?: {
    main: string;
    light: string;
    dark: string;
    contrastText: string;
  };
  error?: {
    main: string;
    light: string;
    dark: string;
  };
  warning?: {
    main: string;
  };
  info?: {
    main: string;
  };
  success?: {
    main: string;
  };
  background: {
    default: string;
    paper: string;
  };
  text: {
    primary: string;
    secondary: string;
    disabled: string;
  };
  divider: string;
}
export interface ThemeOptions {
  palette: PaletteOptions;
  components?: {
    [key: string]: any;
  };
  typography?: {
    fontFamily?: string;
    [key: string]: any;
  };
  spacing: (factor: number) => string;
  shape?: {
    borderRadius: number;
  };
}
export interface ThemeContextType {
  theme: ThemeMode;
  isDark: boolean;
  toggleTheme: () => void;
  setTheme: (theme: ThemeMode) => void;
  getTheme: () => ThemeMode;
  getEffectiveTheme: () => ThemeMode;
  themeOptions: ThemeOptions;
}

================
File: src/types/auth.ts
================
export interface FormData {
  username: string;
  email: string;
  password: string;
}
export interface FormErrors {
  username?: string;
  email?: string;
  password?: string;
  general?: string;
}

================
File: src/types/database.ts
================
import { Types } from 'mongoose';
export interface IUser {
  _id: Types.ObjectId;
  email: string;
  username: string;
  passwordHash: string;
  role: 'user' | 'admin' | 'moderator';
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
  lastLogin?: Date;
}
export interface ISocialLinks {
  website?: string;
  twitter?: string;
  youtube?: string;
  instagram?: string;
  [key: string]: string | undefined;
}
export interface IUserProfileStats {
  postCount: number;
  followerCount: number;
  followingCount: number;
  subscriberCount?: number;
}
export interface IUserPreferences {
  theme: 'light' | 'dark' | 'system';
  notifications: {
    email: boolean;
    push: boolean;
  };
}
export interface IUserProfile {
  _id: Types.ObjectId;
  userId: Types.ObjectId;
  displayName: string;
  bio: string;
  profilePicture?: string;
  coverPhoto?: string;
  socialLinks: ISocialLinks;
  stats: IUserProfileStats;
  preferences: IUserPreferences;
  isCreator: boolean;
  createdAt: Date;
  updatedAt: Date;
}
export interface IDailyStat {
  date: Date;
  postViews: number;
  profileViews: number;
  newFollowers: number;
}
export interface IMonthlyStat {
  month: number;
  year: number;
  totalViews: number;
  totalEngagement: number;
}
export interface IUserStats {
  _id: Types.ObjectId;
  userId: Types.ObjectId;
  dailyStats: IDailyStat[];
  monthlyStats: IMonthlyStat[];
  lastUpdated: Date;
}
export interface IUserRelationship {
  _id: Types.ObjectId;
  followerId: Types.ObjectId;
  followingId: Types.ObjectId;
  createdAt: Date;
}
export interface ISubscriptionTier {
  name: string;
  price: number;
  benefits: string[];
  isActive: boolean;
}
export interface ISubscription {
  _id: Types.ObjectId;
  subscriberId: Types.ObjectId;
  creatorId: Types.ObjectId;
  tier: string;
  status: 'active' | 'cancelled' | 'expired';
  startDate: Date;
  endDate?: Date;
  autoRenew: boolean;
  paymentMethodId?: string;
  lastBillingDate?: Date;
  nextBillingDate?: Date;
  createdAt: Date;
  updatedAt: Date;
}

================
File: src/types/index.ts
================
export interface User {
  id: string;
  username: string;
  name: string;
  email: string;
  bio?: string;
  avatarUrl?: string;
  coverUrl?: string;
  isCreator: boolean;
}
export interface Creator extends User {
  subscriptionLevels: SubscriptionLevel[];
  contentCount: number;
  followerCount: number;
  subscriberCount: number;
}
export interface SubscriptionLevel {
  level: 0 | 1 | 2 | 3;
  price: number;
  name: string;
  description: string;
  features: string[];
}
export interface Content {
  id: string;
  creatorId: string;
  title: string;
  description: string;
  mediaType: 'image' | 'video';
  mediaUrl: string;
  thumbnailUrl: string;
  requiredLevel: 0 | 1 | 2 | 3;
  likes: number;
  comments: Comment[];
  createdAt: string;
}
export interface Comment {
  id: string;
  userId: string;
  username: string;
  text: string;
  createdAt: string;
}

================
File: src/types/user.ts
================
export type UserRole = typeof USER_ROLES[keyof typeof USER_ROLES];
export interface SocialLinks {
  website?: string;
  twitter?: string;
  youtube?: string;
  instagram?: string;
  [key: string]: string | undefined;
}
export interface UserStats {
  postCount: number;
  followerCount: number;
  followingCount: number;
  subscriberCount: number;
  [key: string]: number;
}
export interface UserPreferences {
  theme: 'light' | 'dark' | 'system';
  notifications: {
    email: boolean;
    push: boolean;
  };
  [key: string]: any;
}
export interface UserProfile {
  id: string;
  userId: string;
  username: string;
  email: string;
  role: UserRole;
  emailVerified: boolean;
  displayName: string;
  bio: string;
  profilePicture: string;
  coverPhoto: string;
  socialLinks: SocialLinks;
  stats: UserStats & {
    posts?: number;
    followers?: number;
    subscribers?: number;
    [key: string]: number | undefined;
  };
  preferences: UserPreferences;
  isCreator: boolean;
  isFollowing?: boolean;
  isVerified: boolean;
  lastLogin?: Date;
  createdAt: Date;
  updatedAt: Date;
  posts?: number;
  followers?: number;
  subscribers?: number;
  [key: string]: any;
}
export interface ProfileInput {
  displayName?: string;
  bio?: string;
  profilePicture?: string;
  coverPhoto?: string;
  socialLinks?: Partial<SocialLinks>;
  preferences?: Partial<UserPreferences>;
  isCreator?: boolean;
}
export interface UserSettingsUpdate {
  email?: string;
  currentPassword?: string;
  newPassword?: string;
  preferences?: Partial<UserPreferences>;
}
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
  status?: number;
}
export interface PaginatedResult<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}
export interface UserSearchResult {
  id: string;
  username: string;
  displayName: string;
  profilePicture: string;
  isFollowing: boolean;
  isCreator: boolean;
}
export interface PartialProfileUpdate {
  displayName?: string;
  email?: string;
  profilePicture?: string;
  bio?: string;
  socialLinks?: SocialLinks;
  isCreator?: boolean;
}
export interface FeaturedProfile {
  userId: string;
  username: string;
  displayName: string;
  profilePicture: string;
  bio: string;
  socialLinks: SocialLinks;
  posts?: number;
  followers?: number;
  subscribers?: number;
}
export interface FeaturedProfileConfig {
  userId: string;
  username: string;
  isActive: boolean;
  displayOrder: number;
}

================
File: src/utils/browserEnv.ts
================
import { z } from 'zod';
⋮----
type EnvSchema = typeof envSchema;
type ClientEnv = {
  [K in keyof EnvSchema]: z.infer<EnvSchema[K]>;
};
function parseEnv<T extends Record<string, z.ZodTypeAny>>(schema: T, env: Record<string, string | undefined>): z.infer<z.ZodObject<T>>
const getClientEnv = (): ClientEnv =>
export const validateBrowserEnv = ():

================
File: src/utils/constants.ts
================
export type ApiEndpointKey = keyof typeof API_ENDPOINTS;
export function getApiUrl(endpoint: ApiEndpointKey, baseUrl: string = API_BASE_URL): string

================
File: src/utils/env.ts
================
import { z } from 'zod';
⋮----
const getEnvVars = () =>
export const validateEnv = () =>
⋮----
export type EnvVariables = z.infer<typeof envSchema>;

================
File: src/utils/format.ts
================
export const formatNumber = (num: number, decimals: number = 0): string =>
export const formatCompactNumber = (num: number, decimals: number = 1): string =>
export const formatRelativeTime = (date: Date | string | number): string =>

================
File: src/utils/imageUtils.ts
================
type PlaceholderType = 'hero' | 'featured' | 'thumbnail';
⋮----
export const getStaticImageUrl = (imageName: string): string =>
⋮----
return ''; // Return empty string as fallback
⋮----
/**
 * Gets placeholder image URLs for different UI components.
 * Returns URLs for hero, featured, and thumbnail placeholders.
 *
 * @returns {Record<PlaceholderType, string>} Object mapping placeholder types to their URLs
 *
 * @example
 * const { hero, featured, thumbnail } = getPlaceholderImages();
 * // hero = '/static/images/hero-placeholder.png' (in development)
 */
export const getPlaceholderImages = (): Record<PlaceholderType, string> =>
export const getPlaceholderImage = (type: PlaceholderType): string =>

================
File: src/utils/index.ts
================


================
File: src/utils/logger.ts
================
import { env } from './env';
export enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR',
}
interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: Date;
  context?: Record<string, unknown>;
}
interface LoggerOptions {
  logLevel?: LogLevel;
  includeTimestamps?: boolean;
  includeContext?: boolean;
}
class Logger
⋮----
private constructor(options: LoggerOptions =
public static getInstance(options?: LoggerOptions): Logger
private formatMessage(entry: LogEntry): string
private shouldLog(level: LogLevel): boolean
private log(level: LogLevel, message: string, context?: Record<string, unknown>): void
public debug(message: string, context?: Record<string, unknown>)
public info(message: string, context?: Record<string, unknown>)
public warn(message: string, context?: Record<string, unknown>)
public error(message: string, context?: Record<string, unknown>)
public setLogLevel(level: LogLevel): void
public setIncludeTimestamps(include: boolean): void
public setIncludeContext(include: boolean): void
public getLogLevel(): LogLevel

================
File: src/App.tsx
================
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthProvider } from './components/auth/AuthContext';
import { ThemeProvider } from './theme/components/ThemeProvider';
import { LoadingProvider } from './contexts/LoadingContext';
import { UIProvider } from './contexts/UIContext';
import { ProtectedRoute } from './components/auth/ProtectedRoute';
import ProfileLayout from './components/layout/ProfileLayout';
import { Footer } from './components/layout/Footer';
import Toast from './components/Toast';
import HomePageModern from './components/pages/HomePageModern';
import { ExplorePage } from './components/content/ExplorePage';
import { ContentDetail } from './components/content/components/ContentDetail';
import SettingsPage from './components/pages/SettingsPage';
import ProfilePage from './components/pages/ProfilePage';
import { AuthModal } from './components/auth/AuthModal';
import { Navigation } from './components/layout/Navigation';
function App()

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
:root {
[data-theme="dark"],
body {
body:not(.theme-transition) *,
*, *::before, *::after {
input,
.MuiPaper-root {
.MuiButton-root {
.MuiInputBase-root {
.MuiInputBase-root .MuiOutlinedInput-notchedOutline {
.MuiInputBase-root:hover .MuiOutlinedInput-notchedOutline {
.MuiInputBase-root.Mui-focused .MuiOutlinedInput-notchedOutline {
.MuiInputLabel-root {
.MuiInputLabel-root.Mui-focused {
::-webkit-scrollbar {
::-webkit-scrollbar-track {
::-webkit-scrollbar-thumb {
.dark ::-webkit-scrollbar-thumb {
::-webkit-scrollbar-thumb:hover {
* {

================
File: src/main.tsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
⋮----
import { validateBrowserEnv } from './utils/browserEnv';

================
File: src/test-esm.js
================
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
console.log('ES Modules are working!');
console.log('Current file:', __filename);
console.log('Current directory:', __dirname);

================
File: src/vite-env.d.ts
================


================
File: .babelrc
================
{
  "presets": [
    ["@babel/preset-env", {
      "targets": "> 0.25%, not dead",
      "useBuiltIns": "entry",
      "corejs": 3
    }],
    "@babel/preset-react"
  ]
}

================
File: .browserslistrc
================
# Browsers that we support

# Last 2 versions of all major browsers
last 2 versions

# Browsers with market share > 0.5%
> 0.5%

# Not dead browsers (no official updates in the last 24 months)
not dead

# Specific browser versions
not ie <= 11
not op_mini all

# Specific browser versions with market share > 1%
and_chr >= 90
and_ff >= 90
and_uc >= 13.4
android >= 6
chrome >= 90
chromeandroid >= 90
edge >= 90
firefox >= 90
ios_saf >= 14
op_mob >= 64
opera >= 76
safari >= 14
samsung >= 14.0

================
File: .editorconfig
================
# EditorConfig is awesome: https://EditorConfig.org

# Top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
indent_style = space
indent_size = 2

# Markdown files
[*.md]
trim_trailing_whitespace = false

# JSON files
[*.json]
indent_size = 2

# YAML files
[*.{yaml,yml}]
indent_size = 2

# Shell scripts
[*.sh]
indent_style = tab
indent_size = 4

# Makefiles
[Makefile]
indent_style = tab

# Batch files
[*.{cmd,bat}]
end_of_line = crlf

# Docker files
[Dockerfile*]
indent_style = space
indent_size = 4

# Git configuration
[.git{attributes,config,ignore,modules}]
indent_style = tab
indent_size = 4

# NPM configuration
[package.json]
indent_style = space
indent_size = 2

# TypeScript and JavaScript
[*.{js,jsx,ts,tsx}]
indent_style = space
indent_size = 2

# CSS, SCSS, and Less
[*.{css,scss,less}]
indent_style = space
indent_size = 2

# HTML and templates
[*.{html,htm}]
indent_style = space
indent_size = 2

# XML and related
[*.{xml,xsd,xslt,xsx}]
indent_style = space
indent_size = 2

# Markdown
[*.md]
trim_trailing_whitespace = false

# JSON
[*.json]
indent_style = space
indent_size = 2

# YAML
[*.{yaml,yml}]
indent_style = space
indent_size = 2

# Shell scripts
[*.sh]
indent_style = tab
indent_size = 4

# Makefiles
[Makefile]
indent_style = tab

# Batch files
[*.{cmd,bat}]
end_of_line = crlf

# Docker files
[Dockerfile*]
indent_style = space
indent_size = 4

# Git configuration
[.git{attributes,config,ignore,modules}]
indent_style = tab
indent_size = 4

# NPM configuration
[package.json]
indent_style = space
indent_size = 2

================
File: .env.example
================
# ===================================
# SushFlix Environment Configuration
# ===================================
# Copy this file to .env and update the values
# NEVER commit .env to version control!
# ===================================

# ==============
# App Configuration
# ==============
NODE_ENV=development
PORT=5173

# ==============
# API Configuration
# ==============
VITE_API_URL=http://localhost:5173/api
VITE_APP_NAME=SushFlix
VITE_APP_VERSION=1.0.0

# ==============
# Authentication
# ==============
# Generate a strong secret: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
JWT_SECRET=your_64_character_long_jwt_secret_here
JWT_EXPIRES_IN=7d
JWT_REFRESH_EXPIRES_IN=30d

# ==============
# Database (MongoDB)
# ==============
MONGODB_URI=mongodb://localhost:27017/sushflix_development
MONGODB_TEST_URI=mongodb://localhost:27017/sushflix_test

# ==============
# AWS S3 Storage
# ==============
# Required for file uploads and media storage
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key
AWS_REGION=us-east-1
AWS_BUCKET_NAME=your-s3-bucket-name
AWS_S3_ENDPOINT= # Optional: For non-AWS S3 compatible services

# ==============
# Email Service
# ==============
# SMTP Configuration
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_SECURE=false # true for 465, false for other ports
SMTP_USER=your_email@example.com
SMTP_PASS=your_email_password
SMTP_FROM='SushFlix <noreply@example.com>'

# ==============
# Security
# ==============
# Rate limiting
RATE_LIMIT_WINDOW_MS=900000 # 15 minutes
RATE_LIMIT_MAX=100 # Max requests per window per IP

# CORS
CORS_ORIGIN=http://localhost:5173

# ==============
# Analytics & Monitoring
# ==============
# Sentry (Error Tracking)
SENTRY_DSN=your_sentry_dsn_here

# Google Analytics
NEXT_PUBLIC_GA_TRACKING_ID=UA-XXXXXXXX-X

# ==============
# Feature Flags
# ==============
FEATURE_REGISTRATION=true
FEATURE_EMAIL_VERIFICATION=true
FEATURE_PASSWORD_RESET=true
SMTP_FROM=your_email@example.com

# Feature Flags
ENABLE_ANALYTICS=false
ENABLE_MAINTENANCE_MODE=false

# Environment
NODE_ENV=development

================
File: .eslintignore
================
# Dependencies
node_modules

# Build output
dist
build

# Test coverage
coverage

# Environment files
.env*
!.env.example

# IDE
.vscode
.idea

# Misc
.DS_Store
*.log

================
File: .eslintrc.js
================


================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto eol=lf

# Source code files
*.{js,jsx,ts,tsx,json,html,css,scss,less,md,yml,yaml} text eol=lf

# Binary files that should not be modified
*.{png,jpg,jpeg,gif,ico,svg,ttf,woff,woff2,eot,mp4,webm,wav,mp3,m4a,aac,oga,mov,pdf,zip,gz,bz2,xz,tgz,7z,exe,dll,so,dylib,dmg,pkg,app,pdb,lib,a,o,obj,pyc,pyo,pyd,class,jar,war,ear,rar,db,sqlite,sqlite3,sql,sql.gz,tar,tar.gz,tar.bz2,tar.xz,gem} binary

# Windows specific files
*.{cmd,bat} text eol=crlf
*.{ps1,psm1,psd1,ps1xml,psc1,pssc,cdxml} text eol=lf

# Shell scripts
*.sh text eol=lf

# Git merge files
*.{orig,bak,patch,diff} binary

# IDE specific files
.vscode/* text eol=lf
.idea/* text eol=lf
*.{sln,suo,user,userosscache,sln.docstates,vspscc,vssscc,scc,DotSettings} text eol=lf

================
File: .gitignore
================
# Node modules
node_modules/
/.vite


# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Vite build output
dist/
build/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Testing
coverage/

# ES Lint cache
.eslintcache

# npm package verification
package-lock.json
yarn.lock

# MacOS system files
.DS_Store

# Windows system files
Thumbs.db
/dist
/node_modules/
.idea/*
/config/gcp/*

src/server/config/gcp/gcp-key.json

================
File: .npmrc
================
# Ensure consistent package installations
engine-strict=true

# Package lock settings
package-lock=true
package-lock-only=false

# Network settings
fetch-retries=3
fetch-timeout=60000

# Cache settings
cache-min=10
prefer-offline=true

# Security settings
save-prefix=^
audit-level=high
fund=false

# Workspace settings
workspaces-prefix=optional

# Ensure peer dependencies are installed
auto-install-peers=true

================
File: .nvmrc
================
18.18.2

================
File: .prettierignore
================
# Dependencies
node_modules
.pnp
.pnp.js

# Testing
coverage

# Production
build
dist
.next
out

# Misc
.DS_Store
*.pem

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

================
File: .prettierrc
================
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "useTabs": false,
  "printWidth": 100,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "auto"
}

================
File: cloudbuild.yaml
================
steps:
  - name: 'gcr.io/cloud-builders/docker'
    args: [
      'build',
      '-t',
      'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix-backend',
      './src/server'
    ]
    timeout: '1200s'
  - name: 'gcr.io/cloud-builders/docker'
    args: [
      'push',
      'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix-backend'
    ]
  - name: 'gcr.io/cloud-builders/gcloud'
    args:
      [
        'run',
        'deploy',
        'sushflix-backend',
        '--image',
        'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix-backend',
        '--platform',
        'managed',
        '--region',
        'us-central1',
        '--allow-unauthenticated',
        '--set-secrets',
        'MONGODB_URI=mongodb-uri:latest,JWT_SECRET=jwt-secret:latest',
        '--update-env-vars',
        'GCS_BUCKET_NAME=user-profile-pictures-sushflix,NODE_ENV=production'
      ]
  - name: 'gcr.io/cloud-builders/docker'
    args: [
      'build',
      '-t',
      'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix',
      '.',
      '--build-arg',
      'VITE_BACKEND_URL=https://sushflix-backend-796527544626.us-central1.run.app',
      '--build-arg',
      'VITE_GCS_BUCKET_NAME=user-profile-pictures-sushflix'
    ]
    timeout: '1200s'
  - name: 'gcr.io/cloud-builders/docker'
    args: [
      'push',
      'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix'
    ]
  - name: 'gcr.io/cloud-builders/gcloud'
    args:
      [
        'run',
        'deploy',
        'sushflix',
        '--image',
        'us-central1-docker.pkg.dev/$PROJECT_ID/sushflix-repo/sushflix',
        '--platform',
        'managed',
        '--region',
        'us-central1',
        '--allow-unauthenticated'
      ]
logsBucket: gs://sushflix-logs

================
File: cypress.config.ts
================
import { defineConfig } from 'cypress';
⋮----
setupNodeEvents(on, config)

================
File: Dockerfile
================
# Stage 1: Build the React application
FROM node:20.18.1 as builder

WORKDIR /app

# Accept build arguments
ARG VITE_BACKEND_URL
ARG VITE_CLIENT_ID

# Set environment variables for the build process
ENV VITE_BACKEND_URL=$VITE_BACKEND_URL
ENV VITE_CLIENT_ID=$VITE_CLIENT_ID

# Copy package files first for better caching
COPY package*.json ./

RUN npm install

# Copy the rest of the application code
COPY . .

# Build the application
RUN npm run build

# Stage 2: Serve the application with Nginx
FROM nginx:alpine

# Copy the built React app from the builder stage to the Nginx public directory
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy the custom nginx.conf
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80 for the web server (documentation only)
EXPOSE 80

# Command to run Nginx, substituting the PORT environment variable using sed (shell form)
CMD sed -i "s|LISTEN_PORT|$PORT|g" /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'

================
File: Dockerfile.server
================
FROM node:18-slim

WORKDIR /app

# Copy package files first for better caching
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy the rest of the application code
COPY . .

# Set environment variables
ENV NODE_ENV=production
ENV PORT=8080

# Expose port
EXPOSE 8080

# Start the server
CMD ["npm", "run", "server"]

================
File: eslint.config.js
================
export default tseslint.config(

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SushFlix</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.tsx"></script>
  </body>
</html>

================
File: intro.txt
================
Project Overview: Sushflix

Sushflix is a content-sharing and subscription platform that connects content creators with their fans. Creators can upload various types of content, manage their subscriptions, and engage with their followers. Fans can subscribe to their favorite creators, access exclusive content, and support creators through subscriptions.

Key Features:

Content Creation and Management: Creators can upload, store, retrieve, and manage their content.
User Authentication: Secure user signup and login functionality.
Subscription System: Fans can subscribe to creators, with payment processing handled via Stripe.
User Profiles: Creators and fans have their own profiles.
Content Discovery: Users can browse and search for content.
Creator dashboard: Creators have a dashboard where they can see the analytics of their content.
And more... There are many features to be implemented in the future.
Tech Stack:

Frontend: React (a JavaScript library for building user interfaces)
Backend: Node.js/Express (a JavaScript runtime environment and web framework for building server-side applications)
Database: MongoDB Atlas (a cloud-based NoSQL document database)
Storage: AWS S3 (cloud-based object storage)
Deployment:
Frontend deployment via Netlify.
Backend deployment on AWS EC2.
Nginx configuration for reverse proxy.
PM2 for process management.
SSL certificate setup with Let's Encrypt.
Important Files and Their Roles:

Let's break down the codebase by some of the most critical files and their responsibilities:

1. Frontend (src/ directory):

src/App.tsx:
Role: The main entry point for the React application. This file sets up the application's overall structure, including routing.
Importance: If you need to add a new page or change the overall layout of the app, you'll likely modify this file.
src/main.tsx:
Role: This file bootstraps the React application, mounting it to the DOM.
Importance: This file is where the App.tsx component is mounted to the DOM.
src/components/layout/Navigation.tsx:
Role: This file defines the main navigation bar that appears at the top of most pages. It includes links to different sections of the site (e.g., "Explore," "Subscribe," "Login," etc.)
Importance: If you need to change the navigation links or add new ones, you'll modify this file. It also contains the login modal implementation.
src/components/common/Modal.tsx:
Role: This file defines a reusable Modal component, which is a popup card used for various purposes (like the login form).
Importance: When you need to create a new popup or change the modal's style, this is the place to go.
src/components/auth/LoginForm.tsx:
Role: This file contains the LoginForm component, which handles user login.
Importance: If you need to change the login form's structure, the login logic or add fields, you'll modify this file.
src/components/auth/AuthContext.tsx:
Role: This file uses React's Context API to manage authentication state globally.
Importance: It provides the current authentication state and login function.
src/services/apiService.ts:
Role: This file manages the connections to the api.
Importance: If you need to make new requests, this is where you should make them.
2. Backend:

src/server/index.js:
Role: The main entry point for the Node.js/Express backend server. It sets up the server, routes, and middleware.
Importance: Changes to overall server setup should be made here.
src/server/routes:
Role: The routes of the server are defined here.
Importance: New routes should be added here.
src/server/middlewares/auth.js:
Role: Contains the authentication middleware for the server.
Importance: This is where the requests are validated to see if they are authenticated.
3. Documentation:

readme.md:
Role: The project's main documentation file.
Importance: This is the first place a new developer should look for a high-level overview of the project, its features, and how to get started.
issues.md:
Role: Contains a list of the project's issues.
Importance: You can check it to see what issues the project has.
features.md:
Role: Contains a list of the project's features.
Importance: You can check it to see what features the project has.
Key Concepts to Understand:

React Components: The frontend is built using React components, which are reusable building blocks for the UI.
Routing: react-router-dom is used for client-side routing, allowing navigation between different pages or views without full page reloads.
State Management: React's useState hook is used for managing state within components. Context (AuthContext) is used for global state.
API Calls: The frontend makes API calls to the backend to fetch and send data.
Tailwind: It is a CSS framework to style the components.
How to Approach the Codebase:

Start with readme.md: Read the readme.md file to get a general understanding of the project.
Explore App.tsx: Look at App.tsx to see the overall structure and how routing is set up.
Follow the Navigation: Explore Navigation.tsx to understand how different parts of the app are connected.
Study LoginForm.tsx: Examine LoginForm.tsx to see how forms and authentication are handled.
Look at Modal.tsx: Understand how the modal component works.
Check apiService.ts: Understand how the API requests are done.
Check the backend: Look at the backend code to understand how the server is structured

 your task is simple to follow the best coding standards, keep note of whats wrong and what could be a bug. I dont want any explanation or just minimal one liners about what you did and no unnecessary wasting of tokens, got it?

================
File: jest.config.js
================


================
File: nginx.conf
================
server {
    listen LISTEN_PORT;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }
}

================
File: package.json
================
{
  "name": "sushflix",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "engines": {
    "node": ">=18.0.0"
  },
  "scripts": {
    "dev": "set NODE_OPTIONS=--max-old-space-size=4096 && vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "server": "node src/server/server.js",
    "server:dev": "nodemon src/server/server.js",
    "start": "concurrently \"npm run server:dev\" \"npm run dev\"",
    "test": "jest",
    "test:e2e": "cypress run",
    "test:integration": "jest --config jest.integration.config.js",
    "deploy:server": "gcloud run deploy sushflix-backend --source . --region us-central1 --allow-unauthenticated --quiet --dockerfile Dockerfile.server",
    "deploy": "npm run build && npm run deploy:server"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.0.2",
    "@mui/lab": "^7.0.0-beta.11",
    "@mui/material": "^7.0.2",
    "@mui/x-date-pickers": "^8.3.1",
    "@tanstack/react-query": "^5.75.1",
    "@types/mongoose": "^5.11.97",
    "@types/react-dropzone": "^5.1.0",
    "axios": "^1.9.0",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.21.1",
    "express-async-handler": "^1.2.0",
    "framer-motion": "^12.10.5",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.344.0",
    "mongoose": "^8.14.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "multer-s3": "^3.0.1",
    "nodemailer": "^6.9.11",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.3.8",
    "react-router-dom": "^6.30.0",
    "sharp": "^0.34.1",
    "socket.io": "^4.7.4",
    "socket.io-client": "^4.7.4",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-proposal-decorators": "^7.27.1",
    "@babel/plugin-syntax-dynamic-import": "^7.8.3",
    "@babel/plugin-transform-runtime": "^7.27.1",
    "@fullhuman/postcss-purgecss": "^5.0.0",
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/typography": "^0.5.16",
    "@types/bcryptjs": "^2.4.6",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.11",
    "@types/nodemailer": "^6.4.14",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.1.1",
    "@typescript-eslint/parser": "^7.1.1",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.20",
    "browserify-zlib": "^0.2.0",
    "crypto-browserify": "^3.12.1",
    "cssnano": "^6.0.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "https-browserify": "^1.0.0",
    "lighthouse": "^12.6.0",
    "nodemon": "^3.1.0",
    "os-browserify": "^0.3.0",
    "path-browserify": "^1.0.1",
    "postcss": "^8.4.47",
    "postcss-nesting": "^13.0.1",
    "postcss-preset-env": "^10.1.6",
    "querystring-es3": "^0.2.1",
    "rollup-plugin-visualizer": "^5.14.0",
    "source-map-explorer": "^2.5.3",
    "stream-browserify": "^3.0.0",
    "stream-http": "^3.2.0",
    "tailwindcss": "^3.4.14",
    "typescript": "^5.3.3",
    "vite": "^5.1.4",
    "vite-plugin-chunk-split": "^0.5.0",
    "vite-plugin-html": "^3.2.2",
    "vite-plugin-image-optimizer": "^1.1.8",
    "vite-plugin-pwa": "^0.20.0",
    "vite-plugin-style-import": "^2.0.0",
    "vite-tsconfig-paths": "^4.3.2",
    "vitest": "^1.6.0",
    "web-vitals": "^3.5.2",
    "zod": "^3.24.4"
  }
}

================
File: postcss.config.js
================
production && purgecss({
⋮----
defaultExtractor: (content) => {
const broadMatches = content.match(/[^<>"'`\s]*[^<>"'`\s:]/g) || [];
// Capture classes within other delimiters like .block(class="w-1/2" in pug)
const innerMatches = content.match(/[^<>"'`\s.(){}[\]]+[^<>"'`\s.(){}[\]:]/g) || [];
return broadMatches.concat(innerMatches);
⋮----
production && cssnano({
⋮----
postcssPresetEnv({
⋮----
].filter(Boolean),

================
File: tailwind.config.js
================
const hexToRgb = (hex) => {
const r = parseInt(hex.slice(1, 3), 16);
const g = parseInt(hex.slice(3, 5), 16);
const b = parseInt(hex.slice(5, 7), 16);
⋮----
const getThemeColors = () => {
⋮----
const themeColors = getThemeColors();
const generateThemeVars = () => {
⋮----
const flattenTheme = (obj, parentKey = '', target) => {
Object.entries(obj).forEach(([key, value]) => {
⋮----
if (value && typeof value === 'object' && !Array.isArray(value)) {
flattenTheme(value, cssVar, target);
⋮----
flattenTheme(themeColors.light, 'color', lightVars);
flattenTheme(themeColors.dark, 'color', darkVars);
⋮----
...generateThemeVars(),
⋮----
addComponents({

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    /* Language and Environment */
    "target": "ESNext",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    /* Modules */
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "checkJs": false,
    "allowImportingTsExtensions": true,
    "moduleDetection": "force",

    /* Emit */
    "noEmit": true,
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo",

    /* Type Checking */
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "useUnknownInCatchVariables": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": false, // Disable to avoid issues with React.Component methods
    "noPropertyAccessFromIndexSignature": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    /* Path Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    /* Completeness */
    "skipDefaultLibCheck": true
  },
  "include": [
    "src",
    "vite-env.d.ts"
  ],
  "exclude": ["node_modules", "dist", "build"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" },
    { "path": "./tsconfig.paths.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    /* Language and Environment */
    "target": "ESNext",
    "lib": ["ESNext"],
    "module": "ESNext",
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Type Checking */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.paths.json
================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}

================
File: tsconfig.server.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/server/**/*"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
⋮----
// Resolve configuration

================
File: webpack.config.js
================
path: path.resolve(__dirname, 'dist'),
⋮----
new HtmlWebpackPlugin({
⋮----
contentBase: path.join(__dirname, 'dist'),



================================================================
End of Codebase
================================================================
